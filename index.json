[{"content":"","date":"2025-10-18","externalUrl":null,"permalink":"/en/tags/procedural-programming/","section":"Tags","summary":"","title":"Procedural Programming","type":"tags"},{"content":"","date":"2025-10-18","externalUrl":null,"permalink":"/en/tags/programming-paradigm/","section":"Tags","summary":"","title":"Programming Paradigm","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/","section":"0AndWild_log","summary":"","title":"0AndWild_log","type":"page"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/categories/blog/","section":"Categories","summary":"","title":"Blog","type":"categories"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/comments/","section":"Tags","summary":"","title":"Comments","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/giscus/","section":"Tags","summary":"","title":"Giscus","type":"tags"},{"content":" Giscus란? # Giscus는 GitHub Discussions를 백엔드로 사용하는 오픈소스 댓글 시스템입니다.\n주요 특징 # ✅ 완전 무료 (GitHub 기능 활용) ✅ 서버 불필요 (GitHub이 모든 것을 처리) ✅ Markdown 완벽 지원 (코드 블록, 이미지, 표 등) ✅ 반응(Reactions) (👍, ❤️, 😄 등) ✅ GitHub 알림 (댓글 달리면 알림 받음) ✅ 다크모드 (블로그 테마와 자동 동기화) ✅ 데이터 소유 (본인 저장소에 저장) Utterances와의 차이점 # 기능 Giscus Utterances 백엔드 GitHub Discussions GitHub Issues 반응 ✅ ❌ 대댓글 ✅ (중첩) ⚠️ (flat) 댓글 정렬 ✅ ⚠️ 적합성 댓글 전용 이슈 트래킹 결론: Giscus가 Utterances의 상위 호환입니다.\n사전 준비 # 필요한 것 # GitHub 계정 Public GitHub 저장소 (블로그 저장소) Hugo + Blowfish 테마 제약사항 # ⚠️ Public 저장소만 가능 (Private 저장소는 Discussions 기능 제한) ⚠️ GitHub 계정 필요 (익명 댓글 불가) 1단계: GitHub Discussions 활성화 # 1.1 저장소 설정 페이지 이동 # GitHub에서 블로그 저장소 접속\n예: https://github.com/0AndWild/0AndWild.github.io Settings 탭 클릭\n1.2 Discussions 활성화 # 페이지를 아래로 스크롤하여 Features 섹션 찾기\nDiscussions 체크박스를 ✅ 체크\n자동으로 저장됨\n1.3 확인 # 저장소 상단에 Discussions 탭이 생성되었는지 확인\nCode | Issues | Pull requests | Discussions | ← 새로 생김! 2단계: Giscus App 설치 # 2.1 Giscus GitHub App 설치 # https://github.com/apps/giscus 접속\nInstall 버튼 클릭\n권한 선택:\nAll repositories (모든 저장소) Only select repositories (특정 저장소만 - 권장) 블로그 저장소 선택:\n0AndWild/0AndWild.github.io Install 클릭\n2.2 권한 확인 # Giscus가 요청하는 권한:\n✅ Read access to discussions (토론 읽기) ✅ Write access to discussions (토론 쓰기) ✅ Read access to metadata (메타데이터 읽기) 3단계: Giscus 설정 생성 # 3.1 Giscus 웹사이트 접속 # https://giscus.app/ko 방문\n3.2 저장소 연결 # 저장소 섹션에 입력:\n0AndWild/0AndWild.github.io 아래에 성공 메시지가 표시되어야 함:\n✅ 성공! 이 저장소는 모든 조건을 만족합니다. 만약 오류가 뜨면:\nDiscussions 활성화 확인 Giscus App 설치 확인 저장소가 Public인지 확인 3.3 페이지 ↔️ Discussion 연결 방식 # Discussion 카테고리 섹션에서 선택:\n권장: pathname (경로명) # 매핑: pathname 선택 각 블로그 포스트의 경로가 Discussion 제목이 됩니다.\n예시:\n포스트: /posts/giscus-guide/ Discussion 제목: posts/giscus-guide 대안들: # URL: 전체 URL 사용 (도메인 변경 시 문제) title: 포스트 제목 사용 (제목 변경 시 문제) og:title: OpenGraph 제목 specific term: 직접 지정 추천: pathname 사용\n3.4 Discussion 카테고리 선택 # Discussion 카테고리 드롭다운에서 선택:\n권장: Announcements # 카테고리: Announcements 선택 특징:\n관리자만 새 Discussion 생성 가능 댓글은 누구나 가능 블로그 포스트용으로 최적 대안: General # 누구나 Discussion 생성 가능 더 개방적 추천: Announcements (블로그에 적합)\n3.5 기능 선택 # 반응 활성화 # ✅ 반응 활성화 사용자가 👍, ❤️, 😄 등으로 반응 가능\n메타데이터 보내기 # □ 메타데이터 보내기 (체크 해제 권장) 불필요한 기능, 꺼두는 것이 좋음\n댓글 입력란 위치 # ⚪ 댓글 위에 ⚪ 댓글 아래 (권장) 권장: 댓글 아래\n기존 댓글을 먼저 읽고 작성하도록 유도 느긋한 로딩 # ✅ 느긋한 로딩 페이지 로딩 속도 향상 (권장)\n3.6 테마 선택 # 권장: preferred_color_scheme # 테마: preferred_color_scheme 동작:\n사용자의 시스템 설정에 따라 자동 전환 다크모드 ↔️ 라이트모드 자동 대안: # light: 항상 밝은 테마 dark: 항상 어두운 테마 transparent_dark: 투명 다크 기타 GitHub 테마들 추천: preferred_color_scheme (자동 전환)\n3.7 언어 설정 # 언어: ko (한국어) 4단계: 생성된 코드 복사 # 4.1 스크립트 복사 # 페이지 하단에 Enable giscus 섹션에서 생성된 코드 복사:\n\u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;R_kgDOxxxxxxxx\u0026#34; data-category=\u0026#34;Announcements\u0026#34; data-category-id=\u0026#34;DIC_kwDOxxxxxxxx\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; data-loading=\u0026#34;lazy\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 4.2 중요한 값들 # data-repo-id: 저장소 고유 ID (자동 생성) data-category-id: 카테고리 고유 ID (자동 생성) 이 값들은 본인의 저장소마다 다르므로, 반드시 Giscus 웹사이트에서 생성된 코드를 사용해야 합니다.\n5단계: Blowfish 테마에 통합 # 5.1 디렉토리 생성 # 터미널에서 블로그 루트 디렉토리로 이동 후:\nmkdir -p layouts/partials 5.2 comments.html 파일 생성 # touch layouts/partials/comments.html 또는 IDE/에디터에서 직접 생성:\nlayouts/ └── partials/ └── comments.html ← 새로 생성 5.3 Giscus 코드 삽입 # layouts/partials/comments.html 파일에 다음 내용 추가:\n\u0026lt;!-- Giscus 댓글 시스템 --\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;R_kgDOxxxxxxxx\u0026#34; data-category=\u0026#34;Announcements\u0026#34; data-category-id=\u0026#34;DIC_kwDOxxxxxxxx\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; data-loading=\u0026#34;lazy\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; ⚠️ 주의: 위의 data-repo-id와 data-category-id 값을 본인의 값으로 교체해야 합니다!\n5.4 params.toml 설정 # config/_default/params.toml 파일을 열고 [article] 섹션에 추가:\n[article] showComments = true # 이 줄 추가 또는 확인 # ... 기타 설정들 이미 showComments 항목이 있다면 true로 설정되어 있는지 확인하세요.\n6단계: 로컬 테스트 # 6.1 Hugo 서버 실행 # hugo server -D 6.2 브라우저에서 확인 # http://localhost:1313 포스트 페이지 하단에 Giscus 댓글 위젯이 표시되어야 합니다.\n6.3 테스트 댓글 작성 # GitHub으로 로그인 버튼 클릭 GitHub OAuth 인증 테스트 댓글 작성 댓글이 표시되는지 확인 6.4 GitHub Discussions 확인 # GitHub 저장소 → Discussions 탭 Announcements 카테고리에 새 Discussion 생성되었는지 확인 Discussion 제목이 포스트 경로인지 확인 7단계: 배포 # 7.1 Git에 커밋 # git add layouts/partials/comments.html git add config/_default/params.toml git commit -m \u0026#34;Add Giscus comments system\u0026#34; 7.2 GitHub에 푸시 # git push origin main 7.3 GitHub Actions 확인 # GitHub Actions가 자동으로 빌드 및 배포를 진행합니다.\n배포 상태 확인:\nGitHub 저장소 → Actions 탭 7.4 배포된 사이트 확인 # https://0andwild.github.io 포스트 페이지에 댓글 위젯이 정상적으로 표시되는지 확인하세요.\n고급 설정 # 다크모드 및 언어 동적 설정 (권장) # Blowfish 테마의 다크모드 토글과 언어 전환에 따라 Giscus가 자동으로 변경되도록 설정하는 완전한 방법입니다.\n완전한 동적 설정 # layouts/partials/comments.html 전체 코드:\n\u0026lt;!-- Giscus Comments with Dynamic Theme and Language --\u0026gt; {{ $lang := .Site.Language.Lang }} {{ $translationKey := .File.TranslationBaseName }} \u0026lt;script\u0026gt; (function() { // Get current theme (dark/light) function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark_tritanopia\u0026#39; : \u0026#39;light_tritanopia\u0026#39;; } // Get language from Hugo template const currentLang = \u0026#39;{{ $lang }}\u0026#39;; // Use file directory path for unified comments across languages // Example: \u0026#34;posts/subscription_alert\u0026#34; for both index.ko.md and index.en.md const discussionId = \u0026#39;{{ .File.Dir | replaceRE \u0026#34;^content/\u0026#34; \u0026#34;\u0026#34; | replaceRE \u0026#34;/$\u0026#34; \u0026#34;\u0026#34; }}\u0026#39;; // Wait for DOM to be ready if (document.readyState === \u0026#39;loading\u0026#39;) { document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, initGiscus); } else { initGiscus(); } function initGiscus() { // Create and insert Giscus script with dynamic settings const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://giscus.app/client.js\u0026#39;; script.setAttribute(\u0026#39;data-repo\u0026#39;, \u0026#39;0AndWild/0AndWild.github.io\u0026#39;); script.setAttribute(\u0026#39;data-repo-id\u0026#39;, \u0026#39;R_kgDOQAqZFA\u0026#39;); script.setAttribute(\u0026#39;data-category\u0026#39;, \u0026#39;General\u0026#39;); script.setAttribute(\u0026#39;data-category-id\u0026#39;, \u0026#39;DIC_kwDOQAqZFM4CwwRg\u0026#39;); script.setAttribute(\u0026#39;data-mapping\u0026#39;, \u0026#39;specific\u0026#39;); script.setAttribute(\u0026#39;data-term\u0026#39;, discussionId); script.setAttribute(\u0026#39;data-strict\u0026#39;, \u0026#39;0\u0026#39;); script.setAttribute(\u0026#39;data-reactions-enabled\u0026#39;, \u0026#39;1\u0026#39;); script.setAttribute(\u0026#39;data-emit-metadata\u0026#39;, \u0026#39;0\u0026#39;); script.setAttribute(\u0026#39;data-input-position\u0026#39;, \u0026#39;bottom\u0026#39;); script.setAttribute(\u0026#39;data-theme\u0026#39;, getGiscusTheme()); script.setAttribute(\u0026#39;data-lang\u0026#39;, currentLang); script.setAttribute(\u0026#39;data-loading\u0026#39;, \u0026#39;lazy\u0026#39;); script.setAttribute(\u0026#39;crossorigin\u0026#39;, \u0026#39;anonymous\u0026#39;); script.async = true; // Find giscus container or create one const container = document.querySelector(\u0026#39;.giscus-container\u0026#39;) || document.currentScript?.parentElement; if (container) { container.appendChild(script); } } // Monitor theme changes and update Giscus function updateGiscusTheme() { const iframe = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); if (!iframe) return; const theme = getGiscusTheme(); try { iframe.contentWindow.postMessage( { giscus: { setConfig: { theme: theme } } }, \u0026#39;https://giscus.app\u0026#39; ); } catch (error) { console.log(\u0026#39;Giscus theme update delayed, will retry...\u0026#39;); } } // Watch for theme changes using MutationObserver const observer = new MutationObserver((mutations) =\u0026gt; { mutations.forEach((mutation) =\u0026gt; { if (mutation.attributeName === \u0026#39;class\u0026#39;) { // Delay update to ensure iframe is ready setTimeout(updateGiscusTheme, 100); } }); }); // Start observing after a short delay setTimeout(() =\u0026gt; { observer.observe(document.documentElement, { attributes: true, attributeFilter: [\u0026#39;class\u0026#39;] }); }, 500); // Update theme when Giscus iframe loads window.addEventListener(\u0026#39;message\u0026#39;, (event) =\u0026gt; { if (event.origin !== \u0026#39;https://giscus.app\u0026#39;) return; if (event.data.giscus) { // Giscus is ready, update theme setTimeout(updateGiscusTheme, 200); } }); })(); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* Ensure Giscus iframe has proper height and displays all content */ .giscus-container { min-height: 300px; } .giscus-container iframe.giscus-frame { width: 100%; border: none; min-height: 300px; } /* Make sure comment actions are visible */ .giscus { overflow: visible !important; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;giscus-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 동작 방식 설명 # 1. 언어 동적 설정 # {{ $lang := .Site.Language.Lang }} const currentLang = \u0026#39;{{ $lang }}\u0026#39;; Hugo 템플릿에서 현재 페이지 언어 가져오기 한국어 페이지: ko, 영어 페이지: en Giscus에 해당 언어로 설정 결과:\n한국어 페이지 → Giscus UI가 한국어로 표시 영어 페이지 → Giscus UI가 영어로 표시 언어 전환 시 페이지 리로드되면서 자동으로 변경 2. 다크모드 동적 설정 # function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark_tritanopia\u0026#39; : \u0026#39;light_tritanopia\u0026#39;; } Blowfish 테마는 다크모드 시 \u0026lt;html class=\u0026quot;dark\u0026quot;\u0026gt; 추가 이를 감지하여 테마 결정 dark_tritanopia / light_tritanopia 테마 사용 (색맹 친화적) 결과:\n페이지 로드 시: 현재 테마 상태로 Giscus 로드 다크모드 토글 클릭 시: 실시간으로 Giscus 테마 변경 3. 언어별 댓글 통합 # const discussionId = \u0026#39;{{ .File.Dir | replaceRE \u0026#34;^content/\u0026#34; \u0026#34;\u0026#34; | replaceRE \u0026#34;/$\u0026#34; \u0026#34;\u0026#34; }}\u0026#39;; 파일 디렉토리 경로를 Discussion ID로 사용 content/posts/subscription_alert/index.ko.md → posts/subscription_alert content/posts/subscription_alert/index.en.md → posts/subscription_alert 같은 ID이므로 한국어/영어 버전이 같은 댓글 공유 결과:\n한국어 포스트에서 작성한 댓글 영어 포스트에서도 동일하게 표시 포스트별로는 별도 Discussion 생성 4. 실시간 테마 변경 감지 # const observer = new MutationObserver((mutations) =\u0026gt; { mutations.forEach((mutation) =\u0026gt; { if (mutation.attributeName === \u0026#39;class\u0026#39;) { setTimeout(updateGiscusTheme, 100); } }); }); MutationObserver로 HTML 클래스 변경 감지 다크모드 토글 클릭 시 즉시 감지 postMessage로 Giscus iframe에 테마 변경 명령 전송 테스트 방법 # # 1. 로컬 서버 실행 hugo server -D # 2. 브라우저에서 확인 http://localhost:1313/posts/subscription_alert/ 테스트 항목:\n✅ 페이지 로드 시 현재 테마(라이트/다크)로 Giscus 표시 ✅ 다크모드 토글 클릭 시 Giscus 테마 즉시 변경 ✅ 언어 전환 (ko → en) 시 Giscus 언어 변경 ✅ 한국어/영어 페이지에서 같은 댓글 표시 테마 옵션 변경 # 다른 테마를 사용하려면 getGiscusTheme() 함수 수정:\n// 기본 테마 function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;; } // 고대비 테마 function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark_high_contrast\u0026#39; : \u0026#39;light_high_contrast\u0026#39;; } // GitHub 스타일 테마 function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark_dimmed\u0026#39; : \u0026#39;light\u0026#39;; } 사용 가능한 테마:\nlight / dark light_high_contrast / dark_high_contrast light_tritanopia / dark_tritanopia (색맹 친화적) dark_dimmed transparent_dark preferred_color_scheme (시스템 설정 따름) 정적 테마 설정 (간단한 방법) # 동적 변경이 필요 없다면 정적으로 설정 가능:\n\u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;R_kgDOxxxxxxxx\u0026#34; data-category=\u0026#34;General\u0026#34; data-category-id=\u0026#34;DIC_kwDOxxxxxxxx\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 장점: 간단함 단점: 실시간 테마 변경 불가, 언어별 댓글 분리됨\n포스트별 댓글 숨기기 # 특정 포스트에서만 댓글을 숨기려면, 해당 포스트의 front matter에:\n--- title: \u0026#34;댓글 없는 포스트\u0026#34; showComments: false # 이 포스트만 댓글 숨김 --- 카테고리별 댓글 분리 # 다른 카테고리의 포스트에 다른 Discussion 카테고리를 사용하려면:\n\u0026lt;!-- 조건부 카테고리 설정 --\u0026gt; \u0026lt;script\u0026gt; const category = {{ if in .Params.categories \u0026#34;Tutorial\u0026#34; }} \u0026#34;DIC_kwDOxxxxTutorial\u0026#34; {{ else }} \u0026#34;DIC_kwDOxxxxGeneral\u0026#34; {{ end }}; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; ... data-category-id=\u0026#34;{{ category }}\u0026#34; ...\u0026gt; \u0026lt;/script\u0026gt; 문제 해결 # 댓글 위젯이 표시되지 않음 # 원인 1: Discussions 미활성화 # 해결: GitHub 저장소 → Settings → Discussions 체크 원인 2: Giscus App 미설치 # 해결: https://github.com/apps/giscus 에서 Install 원인 3: 저장소 ID 오류 # 해결: giscus.app에서 코드 재생성 원인 4: showComments 설정 누락 # # config/_default/params.toml [article] showComments = true # 확인 로그인 버튼만 보이고 댓글 못 씀 # 원인: GitHub OAuth 승인 필요 # 1. \u0026#34;GitHub으로 로그인\u0026#34; 클릭 2. OAuth 권한 승인 3. 저장소로 리다이렉트 4. 댓글 작성 가능 댓글이 저장되지 않음 # 원인: 저장소 권한 문제 # 확인 사항: 1. 저장소가 Public인지 2. Giscus App 권한에 저장소 포함되어 있는지 3. Discussion 카테고리가 존재하는지 다크모드가 동기화 안 됨 # 해결: JavaScript 동기화 코드 추가 # 위의 \u0026ldquo;고급 설정 \u0026gt; 다크모드 자동 전환\u0026rdquo; 참고\nGiscus 관리 # 댓글 관리 # GitHub Discussions에서 관리 # 1. GitHub 저장소 → Discussions 탭 2. 해당 Discussion 클릭 3. 관리 작업: - 댓글 수정 (본인 댓글만) - 댓글 삭제 (관리자) - 사용자 차단 (관리자) - Discussion 잠금 (관리자) 스팸 댓글 처리 # 1. GitHub Discussions에서 스팸 댓글 찾기 2. 댓글 옆 ... 메뉴 → \u0026#34;Delete\u0026#34; 3. 사용자 차단: 프로필 → Block user 알림 설정 # GitHub 알림으로 댓글 알림 받기 # 1. GitHub → Settings → Notifications 2. Watching에 저장소 추가 3. 이메일로 알림 받기 설정 특정 Discussion만 알림 받기 # 1. Discussions 탭 → 해당 Discussion 2. 오른쪽 \u0026#34;Subscribe\u0026#34; 버튼 3. \u0026#34;Notify me\u0026#34; 선택 통계 및 분석 # 댓글 통계 보기 # GitHub Discussions에서:\n1. Discussions 탭 2. 카테고리별 Discussion 수 확인 3. 각 Discussion의 댓글 수 확인 GitHub Insights 활용 # GitHub 저장소 → Insights → Community → Discussions 활동 확인 비용 및 제한사항 # 비용 # 완전 무료\nGitHub 계정만 있으면 사용 가능 저장소 크기 제한 내에서 무제한 댓글 제한사항 # GitHub API Rate Limit # 시간당 60회 (미인증) 시간당 5,000회 (인증) Giscus는 캐싱으로 최적화되어 있어 문제 없음 저장소 크기 # GitHub Free: 저장소당 1GB 텍스트 댓글만으로는 제한 도달 불가능 Discussions 제한 # 없음 (무제한) 대안 비교 # Giscus vs Utterances # 항목 Giscus Utterances 백엔드 Discussions Issues 반응 ✅ ❌ 대댓글 중첩 지원 Flat 추천 ⭐⭐⭐⭐⭐ ⭐⭐⭐ 결론: Giscus 사용 권장\nGiscus vs Disqus # 항목 Giscus Disqus 비용 무료 무료 (광고) 광고 ❌ ✅ 익명 댓글 ❌ ✅ (Guest) Markdown ✅ ⚠️ 데이터 소유 ✅ ❌ 추천 개발자 블로그 일반 블로그 마이그레이션 가이드 # Utterances → Giscus # 1. GitHub Issues를 Discussions로 변환 - 수동 작업 필요 (자동화 없음) - 또는 Issues 그대로 두고 Giscus 새로 시작 2. comments.html 파일 교체 - Utterances 코드 삭제 - Giscus 코드 추가 3. 배포 Disqus → Giscus # 1. Disqus 데이터 Export (XML) 2. GitHub Discussions로 수동 이전 - 자동화 도구 없음 - 스크립트 직접 작성 필요 - 또는 새로 시작 권장 추가 리소스 # 공식 문서 # Giscus 공식 사이트 Giscus GitHub 커뮤니티 # Giscus Discussions Blowfish 문서 체크리스트 # 설치 완료 확인:\nGitHub Discussions 활성화 Giscus App 설치 layouts/partials/comments.html 생성 Giscus 코드 삽입 (본인의 ID로) params.toml에 showComments = true 로컬 테스트 완료 GitHub에 푸시 배포된 사이트에서 확인 테스트 댓글 작성 GitHub Discussions에 생성 확인 결론 # Giscus는 Hugo/GitHub Pages 블로그에 가장 적합한 댓글 시스템입니다:\n장점 정리 # ✅ 완전 무료 ✅ 설정 간단 (10분) ✅ 서버 불필요 ✅ Markdown 완벽 지원 ✅ GitHub 통합 ✅ 데이터 소유\n단점 # ❌ GitHub 계정 필수 (익명 불가) ❌ 기술 블로그에 적합 (일반 사용자는 허들 있음)\n추천 대상 # ✅ 개발자 블로그 ✅ 기술 문서 ✅ 오픈소스 프로젝트 ","date":"2025-10-17","externalUrl":null,"permalink":"/posts/comments_giscus/","section":"Posts","summary":"무료로 Markdown 지원하는 댓글 시스템을 10분 만에 추가하는 방법","title":"Giscus로 Hugo 블로그에 댓글 기능 추가하기","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"GitHub","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"GitHub Pages","type":"tags"},{"content":" 개요 # 정적 사이트 생성기(Hugo)로 만든 블로그에 댓글 기능을 추가하는 모든 방법을 비교 분석합니다. 익명 댓글, GitHub 로그인, 소셜 로그인 등 다양한 요구사항에 맞는 솔루션을 제시합니다.\n댓글 시스템 분류 # 인증 방식에 따른 분류 # 인증 방식 시스템 GitHub 전용 Giscus, Utterances 익명 가능 Remark42, Commento, Comentario, HashOver 익명 + 소셜 로그인 Remark42, Commento, Disqus 소셜 로그인만 Disqus, Hyvor Talk 호스팅 방식에 따른 분류 # 호스팅 시스템 SaaS (관리 불필요) Giscus, Utterances, Disqus, Hyvor Talk 셀프 호스팅 Remark42, Commento, Comentario, HashOver 하이브리드 Cusdis (Vercel 무료 배포) 1. Giscus (최고 추천 - GitHub 사용자용) # 개념 # GitHub Discussions를 백엔드로 사용하는 댓글 시스템\n동작 방식 # 1. 사용자가 블로그 방문 ↓ 2. Giscus 위젯 로드 ↓ 3. GitHub OAuth로 로그인 ↓ 4. 댓글 작성 ↓ 5. GitHub Discussions에 자동 저장 ↓ 6. 블로그에 실시간 표시 장점 # ✅ 완전 무료 (GitHub 기능 활용) ✅ 서버 불필요 (GitHub이 백엔드) ✅ 데이터 소유 (본인 저장소에 저장) ✅ Markdown 지원 (코드 블록, 이미지 등) ✅ 반응(Reactions) 지원 (👍, ❤️ 등) ✅ 알림 (GitHub 알림으로 댓글 알림) ✅ 다크 모드 (블로그 테마와 동기화) ✅ 스팸 방지 (GitHub 계정 필요) ✅ 관리 간편 (GitHub Discussions에서 관리) ✅ 검색 가능 (GitHub 검색으로 댓글 검색) 단점 # ❌ 익명 댓글 불가 (GitHub 계정 필수) ❌ 기술 블로그에 적합 (일반 사용자는 GitHub 계정 없을 수 있음) ❌ GitHub 의존성 (GitHub 장애 시 댓글 불가) 구현 난이도 # ⭐⭐ (2/5)\n설정 방법 # 1단계: GitHub Discussions 활성화 # 1. GitHub 저장소 → Settings 2. Features 섹션 → Discussions 체크 2단계: Giscus 설정 # giscus.app 방문 저장소 입력: username/repository 설정 선택: 페이지 ↔️ Discussion 연결: pathname (권장) Discussion 카테고리: Announcements 또는 General 기능: 반응, 댓글 위로 테마: 블로그에 맞게 선택 3단계: Blowfish에 추가 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;YOUR_REPO_ID\u0026#34; data-category=\u0026#34;Announcements\u0026#34; data-category-id=\u0026#34;YOUR_CATEGORY_ID\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 4단계: params.toml 설정 # [article] showComments = true 테마 동기화 (다크모드) # \u0026lt;script\u0026gt; // 블로그 테마 변경 시 Giscus 테마도 변경 const giscusTheme = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); if (giscusTheme) { const theme = document.documentElement.getAttribute(\u0026#39;data-theme\u0026#39;); giscusTheme.contentWindow.postMessage({ giscus: { setConfig: { theme: theme === \u0026#39;dark\u0026#39; ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39; } } }, \u0026#39;https://giscus.app\u0026#39;); } \u0026lt;/script\u0026gt; 비용 # 완전 무료\n추천 대상 # ✅ 개발자 블로그 ✅ 기술 문서 ✅ 오픈소스 프로젝트 블로그 2. Utterances # 개념 # GitHub Issues를 백엔드로 사용하는 댓글 시스템 (Giscus의 전신)\n동작 방식 # 1. GitHub OAuth 로그인 ↓ 2. 댓글 작성 ↓ 3. GitHub Issues에 저장 (각 포스트 = 1개 Issue) ↓ 4. 블로그에 표시 장점 # ✅ 완전 무료 ✅ 가벼움 (TypeScript) ✅ 간단한 설정 ✅ Markdown 지원 단점 # ❌ Issues 사용 (Discussions보다 덜 적합) ❌ Giscus보다 기능 적음 ❌ 익명 불가 Giscus vs Utterances # 기능 Giscus Utterances 백엔드 Discussions Issues 반응 ✅ ❌ 댓글에 댓글 ✅ (nested) ⚠️ (flat) 적합성 댓글 전용 이슈 트래킹용 결론: Giscus가 Utterances의 상위 호환\n구현 난이도 # ⭐⭐ (2/5)\n설정 방법 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;username/repository\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 추천 대상 # 특별한 이유가 없다면 Giscus 사용 권장 3. Remark42 (최고 추천 - 익명 + 소셜 로그인) # 개념 # 오픈소스 셀프 호스팅 댓글 시스템으로, 익명 및 다양한 소셜 로그인 지원\n동작 방식 # 1. Remark42 서버 배포 (Docker) ↓ 2. 블로그에 Remark42 스크립트 삽입 ↓ 3. 사용자 선택: - 익명 댓글 작성 - GitHub/Google/Twitter 로그인 후 작성 ↓ 4. Remark42 DB에 저장 ↓ 5. 블로그에 표시 장점 # ✅ 익명 댓글 가능 (설정으로 켜고 끌 수 있음) ✅ 다양한 소셜 로그인 (GitHub, Google, Facebook, Twitter, Email) ✅ 완전 무료 (오픈소스) ✅ 광고 없음 ✅ 데이터 소유 (본인 서버) ✅ Markdown 지원 ✅ 댓글 수정/삭제 ✅ 관리자 모드 (댓글 승인/차단/삭제) ✅ 알림 (이메일/Telegram) ✅ Import/Export (다른 시스템에서 마이그레이션) ✅ 투표 (찬성/반대) ✅ 스팸 필터 단점 # ❌ 셀프 호스팅 필요 (Docker 서버) ❌ 유지보수 책임 ❌ 호스팅 비용 (월 $5~, 무료 티어 가능) 구현 난이도 # ⭐⭐⭐⭐ (4/5)\n호스팅 옵션 # 옵션 1: Railway (추천) # 1. Railway.app 회원가입 2. \u0026#34;New Project\u0026#34; → \u0026#34;Deploy from GitHub\u0026#34; 3. Remark42 Docker 이미지 선택 4. 환경변수 설정: - REMARK_URL=https://your-remark42.railway.app - SECRET=your-random-secret - AUTH_ANON=true # 익명 댓글 허용 - AUTH_GITHUB_CID=your_client_id - AUTH_GITHUB_CSEC=your_client_secret Railway 무료 티어:\n월 $5 크레딧 소규모 블로그 충분 옵션 2: Fly.io # # fly.toml app = \u0026#34;my-remark42\u0026#34; [build] image = \u0026#34;umputun/remark42:latest\u0026#34; [env] REMARK_URL = \u0026#34;https://my-remark42.fly.dev\u0026#34; AUTH_ANON = \u0026#34;true\u0026#34; AUTH_GITHUB_CID = \u0026#34;xxx\u0026#34; AUTH_GITHUB_CSEC = \u0026#34;xxx\u0026#34; fly launch fly deploy Fly.io 무료 티어:\n3개 앱 소규모 블로그 충분 옵션 3: Docker Compose (VPS) # # docker-compose.yml version: \u0026#39;3.8\u0026#39; services: remark42: image: umputun/remark42:latest restart: always environment: - REMARK_URL=https://remark.your-blog.com - SECRET=your-secret-key-change-this - AUTH_ANON=true # 익명 허용 - AUTH_GITHUB_CID=xxx # GitHub 로그인 - AUTH_GITHUB_CSEC=xxx - AUTH_GOOGLE_CID=xxx # Google 로그인 - AUTH_GOOGLE_CSEC=xxx - ADMIN_SHARED_ID=github_username # 관리자 volumes: - ./data:/srv/var ports: - \u0026#34;8080:8080\u0026#34; docker-compose up -d 블로그 삽입 코드 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;div id=\u0026#34;remark42\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var remark_config = { host: \u0026#39;https://your-remark42.railway.app\u0026#39;, site_id: \u0026#39;0andwild-blog\u0026#39;, components: [\u0026#39;embed\u0026#39;], theme: \u0026#39;light\u0026#39;, locale: \u0026#39;ko\u0026#39;, max_shown_comments: 10, simple_view: false, no_footer: false }; (function(c) { for(var i = 0; i \u0026lt; c.length; i++){ var d = document, s = d.createElement(\u0026#39;script\u0026#39;); s.src = remark_config.host + \u0026#39;/web/\u0026#39; +c[i] +\u0026#39;.js\u0026#39;; s.defer = true; (d.head || d.body).appendChild(s); } })(remark_config.components || [\u0026#39;embed\u0026#39;]); \u0026lt;/script\u0026gt; 익명 + GitHub 동시 사용 설정 # # 환경변수 AUTH_ANON=true # 익명 허용 AUTH_GITHUB_CID=xxx # GitHub OAuth App ID AUTH_GITHUB_CSEC=xxx # GitHub OAuth App Secret ANON_VOTE=false # 익명 사용자 투표 불가 (스팸 방지) 사용자는 선택 가능:\n\u0026ldquo;익명으로 댓글 달기\u0026rdquo; \u0026ldquo;GitHub으로 로그인\u0026rdquo; 관리자 기능 # # 관리자 지정 ADMIN_SHARED_ID=github_yourusername # 또는 이메일 ADMIN_SHARED_EMAIL=you@example.com 관리자 가능 작업:\n댓글 삭제 사용자 차단 댓글 고정 읽기 전용 모드 비용 # Railway: 무료 또는 월 $5 Fly.io: 무료 티어 가능 VPS (DigitalOcean 등): 월 $5~ 추천 대상 # ✅ 익명 + 소셜 로그인 모두 원하는 경우 ✅ 기술적으로 Docker 다룰 수 있는 사용자 ✅ 데이터 완전 통제 원하는 경우 4. Commento / Comentario # 개념 # 프라이버시 중심의 경량 댓글 시스템\nCommento vs Comentario # 항목 Commento Comentario 상태 개발 중단 활발히 개발 중 (Commento 포크) 라이선스 MIT MIT 언어 Go Go 추천 ❌ ✅ 결론: Comentario 사용 권장\nComentario 장점 # ✅ 익명 댓글 가능 ✅ 소셜 로그인 (GitHub, Google, GitLab, SSO) ✅ 가벼움 (Go 기반) ✅ 프라이버시 중심 ✅ Markdown 지원 ✅ 투표 기능 단점 # ❌ 셀프 호스팅 필요 ❌ Remark42보다 기능 적음 구현 난이도 # ⭐⭐⭐⭐ (4/5)\nDocker 배포 # version: \u0026#39;3.8\u0026#39; services: comentario: image: registry.gitlab.com/comentario/comentario ports: - \u0026#34;8080:8080\u0026#34; environment: - COMENTARIO_ORIGIN=https://comments.your-blog.com - COMENTARIO_BIND=0.0.0.0:8080 - COMENTARIO_POSTGRES=postgres://user:pass@db/comentario depends_on: - db db: image: postgres:15 environment: - POSTGRES_DB=comentario - POSTGRES_USER=comentario - POSTGRES_PASSWORD=change-this volumes: - postgres_data:/var/lib/postgresql/data volumes: postgres_data: 블로그 삽입 # \u0026lt;script defer src=\u0026#34;https://comments.your-blog.com/js/commento.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;commento\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 추천 대상 # Remark42 대안 더 간단한 시스템 원하는 경우 5. Disqus (전통적 SaaS) # 개념 # 가장 오래되고 널리 사용되는 클라우드 댓글 시스템\n동작 방식 # 1. Disqus 계정 생성 및 사이트 등록 ↓ 2. 블로그에 Disqus 스크립트 삽입 ↓ 3. 사용자 선택: - Guest (익명 - 이메일 필요) - Disqus 계정 - Facebook/Twitter/Google 로그인 ↓ 4. Disqus 서버에 저장 ↓ 5. 블로그에 표시 장점 # ✅ 설정 초간단 (5분) ✅ 서버 불필요 (SaaS) ✅ Guest 모드 (이메일만으로 댓글) ✅ 소셜 로그인 (Facebook, Twitter, Google) ✅ 강력한 관리자 도구 ✅ 스팸 필터 (Akismet 통합) ✅ 모바일 앱 (iOS/Android) ✅ 분석/통계 단점 # ❌ 광고 표시 (무료 플랜) ❌ 무거움 (스크립트 크기) ❌ 프라이버시 우려 (데이터 추적) ❌ 데이터 소유권 없음 (Disqus 서버) ❌ GitHub 로그인 없음 ❌ 광고 제거 비용 (월 $11.99~) 구현 난이도 # ⭐ (1/5) - 가장 쉬움\n설정 방법 # 1단계: Disqus 사이트 등록 # 1. disqus.com 가입 2. \u0026#34;I want to install Disqus on my site\u0026#34; 선택 3. Website Name 입력 (예: andwild-blog) 4. Category 선택 5. Plan 선택 (Basic - Free) 2단계: Blowfish 설정 # # config/_default/config.toml [services.disqus] shortname = \u0026#34;andwild-blog\u0026#34; # 1단계에서 생성한 이름 # config/_default/params.toml [article] showComments = true Hugo는 Disqus를 기본 지원하므로 자동으로 댓글 표시됨!\n3단계: Guest 댓글 허용 # Disqus Dashboard → Settings → Community → Guest Commenting: Allow guests to comment (체크) 광고 제거 방법 # 방법 1: 유료 플랜 ($11.99/월~) # Plus Plan: 광고 없음 Pro Plan: 광고 없음 + 고급 기능 방법 2: CSS로 숨기기 (비추천 - 약관 위반 가능) # /* 비추천: Disqus 약관 위반 가능 */ #disqus_thread iframe[src*=\u0026#34;ads\u0026#34;] { display: none !important; } 비용 # 무료: 광고 있음 Plus: $11.99/월 (광고 없음) Pro: $89/월 (고급 기능) 추천 대상 # ✅ 빠르게 댓글 추가하고 싶은 경우 ✅ 비기술적 블로거 ✅ 광고 신경 안 쓰는 경우 ❌ 프라이버시 중시하는 경우는 비추천 6. Cusdis (Vercel 무료 배포) # 개념 # 경량 오픈소스 댓글 시스템, Vercel에 무료 배포 가능\n동작 방식 # 1. Cusdis를 Vercel에 배포 (1-Click) ↓ 2. PostgreSQL 연결 (Vercel 무료) ↓ 3. 대시보드에서 사이트 추가 ↓ 4. 블로그에 스크립트 삽입 ↓ 5. 사용자가 이메일 + 이름으로 댓글 장점 # ✅ 완전 무료 (Vercel 무료 티어) ✅ 익명 댓글 (이메일 + 이름만) ✅ 가벼움 (50KB) ✅ 설정 간단 (Vercel 1-Click 배포) ✅ 프라이버시 중심 ✅ 오픈소스 단점 # ❌ Markdown 미지원 ❌ 소셜 로그인 없음 ❌ 기능 단순 구현 난이도 # ⭐⭐⭐ (3/5)\n설정 방법 # 1단계: Vercel 배포 # 1. https://cusdis.com/ 방문 2. \u0026#34;Deploy with Vercel\u0026#34; 클릭 3. GitHub 연결 4. PostgreSQL 추가 (Vercel Storage) 5. 배포 완료 2단계: 사이트 추가 # 1. 배포된 Cusdis 대시보드 접속 2. \u0026#34;Add Website\u0026#34; 클릭 3. Domain 입력: 0andwild.github.io 4. App ID 복사 3단계: 블로그 삽입 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;div id=\u0026#34;cusdis_thread\u0026#34; data-host=\u0026#34;https://your-cusdis.vercel.app\u0026#34; data-app-id=\u0026#34;YOUR_APP_ID\u0026#34; data-page-id=\u0026#34;{{ .File.UniqueID }}\u0026#34; data-page-url=\u0026#34;{{ .Permalink }}\u0026#34; data-page-title=\u0026#34;{{ .Title }}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script async defer src=\u0026#34;https://your-cusdis.vercel.app/js/cusdis.es.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 비용 # 완전 무료 (Vercel 무료 티어)\n추천 대상 # ✅ 간단한 익명 댓글만 필요한 경우 ✅ 완전 무료 원하는 경우 ✅ Vercel 사용 경험 있는 경우 7. HashOver # 개념 # PHP 기반의 완전 익명 댓글 시스템\n장점 # ✅ 완전 익명 (아무 정보도 필요 없음) ✅ PHP + flat file (DB 불필요) ✅ 오픈소스 단점 # ❌ PHP 필요 (정적 사이트에 부적합) ❌ GitHub 로그인 없음 ❌ 오래된 프로젝트 구현 난이도 # ⭐⭐⭐⭐ (4/5)\n추천 대상 # ❌ 정적 블로그에는 비추천 PHP 서버 있을 때만 고려 8. Hyvor Talk (프리미엄 SaaS) # 개념 # 광고 없는 프리미엄 댓글 시스템\n장점 # ✅ 광고 없음 ✅ 익명 댓글 가능 ✅ 소셜 로그인 ✅ 강력한 스팸 필터 단점 # ❌ 유료 (월 $5~) ❌ GitHub 로그인 없음 비용 # Starter: $5/월 (1 사이트) Pro: $15/월 (3 사이트) 추천 대상 # Disqus 유료 대안 광고 없는 SaaS 원하는 경우 비교표 # 인증 방식별 # 시스템 익명 GitHub Google 기타 소셜 난이도 비용 Giscus ❌ ✅ ❌ ❌ ⭐⭐ 무료 Utterances ❌ ✅ ❌ ❌ ⭐⭐ 무료 Remark42 ✅ ✅ ✅ ✅ ⭐⭐⭐⭐ $5/월 Comentario ✅ ✅ ✅ ✅ ⭐⭐⭐⭐ $5/월 Disqus ⚠️ ❌ ✅ ✅ ⭐ 무료 (광고) Cusdis ✅ ❌ ❌ ❌ ⭐⭐⭐ 무료 Hyvor Talk ✅ ❌ ✅ ✅ ⭐ $5/월 기능별 # 시스템 Markdown 반응 투표 알림 관리자 스팸필터 Giscus ✅ ✅ ❌ ✅ ⚠️ ✅ Remark42 ✅ ❌ ✅ ✅ ✅ ✅ Disqus ⚠️ ❌ ✅ ✅ ✅ ✅ Cusdis ❌ ❌ ❌ ⚠️ ✅ ⚠️ 호스팅별 # 시스템 호스팅 데이터 위치 의존성 Giscus GitHub GitHub Discussions GitHub Remark42 셀프 본인 서버 Docker Disqus Disqus Disqus 서버 Disqus Cusdis Vercel Vercel DB Vercel 선택 가이드 # 시나리오별 추천 # 1. \u0026ldquo;개발자 블로그, GitHub 사용자 대상\u0026rdquo; # → Giscus ⭐⭐⭐⭐⭐\n무료, 간단, Markdown 지원 GitHub 통합으로 알림도 편함 2. \u0026ldquo;일반 블로그, 익명 댓글 필수\u0026rdquo; # → Cusdis (간단) 또는 Remark42 (고급)\nCusdis: 5분 설정, 완전 무료 Remark42: 더 많은 기능, 소셜 로그인 포함 3. \u0026ldquo;익명 + GitHub 로그인 둘 다\u0026rdquo; # → Remark42 ⭐⭐⭐⭐⭐\n유일하게 둘 다 지원 관리자 기능 강력 4. \u0026ldquo;기술 없음, 빠르게 설정\u0026rdquo; # → Disqus\n5분 설정 광고는 감수 5. \u0026ldquo;완전 무료 + 서버 관리 싫음\u0026rdquo; # → Giscus (GitHub) 또는 Cusdis (익명)\n6. \u0026ldquo;프라이버시 최우선\u0026rdquo; # → Remark42 또는 Comentario (셀프 호스팅)\n데이터 완전 통제 실전 구현: Blowfish + Giscus # 전체 설정 과정 # 1. GitHub Discussions 활성화 # GitHub 저장소 → Settings → Features → Discussions 체크 2. Giscus App 설치 # https://github.com/apps/giscus 방문 → Install → 저장소 선택 3. Giscus 설정 생성 # giscus.app/ko에서:\n저장소: 0AndWild/0AndWild.github.io 매핑: pathname 카테고리: Announcements 테마: preferred_color_scheme 언어: ko 생성된 코드 복사\n4. 파일 생성 # # 디렉토리 생성 (없으면) mkdir -p layouts/partials # 파일 생성 touch layouts/partials/comments.html 5. 코드 삽입 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;R_xxxxxxxxxxxxx\u0026#34; data-category=\u0026#34;Announcements\u0026#34; data-category-id=\u0026#34;DIC_xxxxxxxxxxxxx\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 6. params.toml 수정 # [article] showComments = true 7. 로컬 테스트 # hugo server -D # http://localhost:1313 에서 확인 8. 배포 # git add . git commit -m \u0026#34;Add Giscus comments\u0026#34; git push 실전 구현: Blowfish + Remark42 (Railway) # 전체 설정 과정 # 1. GitHub OAuth App 생성 # GitHub → Settings → Developer settings → OAuth Apps → New OAuth App Application name: AndWild Blog Comments Homepage URL: https://0andwild.github.io Authorization callback URL: https://your-remark42.railway.app/auth/github/callback 생성 후: Client ID 복사 Client Secret 생성 및 복사 2. Railway 배포 # 1. railway.app 가입 2. \u0026#34;New Project\u0026#34; → \u0026#34;Deploy Docker Image\u0026#34; 3. Image: umputun/remark42:latest 4. 환경변수 추가: REMARK_URL=https://your-project.railway.app SECRET=randomly-generated-secret-key-change-this SITE=0andwild-blog AUTH_ANON=true AUTH_GITHUB_CID=your_github_client_id AUTH_GITHUB_CSEC=your_github_client_secret ADMIN_SHARED_ID=github_yourusername 3. 배포 확인 # Railway가 자동으로 URL 생성: https://your-project.railway.app 브라우저에서 접속하여 Remark42 UI 확인 4. Blowfish 설정 # mkdir -p layouts/partials touch layouts/partials/comments.html \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;div id=\u0026#34;remark42\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var remark_config = { host: \u0026#39;https://your-project.railway.app\u0026#39;, site_id: \u0026#39;0andwild-blog\u0026#39;, components: [\u0026#39;embed\u0026#39;], theme: \u0026#39;light\u0026#39;, locale: \u0026#39;ko\u0026#39; }; (function(c) { for(var i = 0; i \u0026lt; c.length; i++){ var d = document, s = d.createElement(\u0026#39;script\u0026#39;); s.src = remark_config.host + \u0026#39;/web/\u0026#39; +c[i] +\u0026#39;.js\u0026#39;; s.defer = true; (d.head || d.body).appendChild(s); } })(remark_config.components || [\u0026#39;embed\u0026#39;]); \u0026lt;/script\u0026gt; 5. params.toml # [article] showComments = true 6. 테스트 및 배포 # hugo server -D # 확인 후 git add . git commit -m \u0026#34;Add Remark42 comments\u0026#34; git push 마이그레이션 가이드 # Disqus → Giscus # 1. Disqus에서 데이터 Export (XML) 2. GitHub Discussions로 수동 이전 (자동화 스크립트 없음, 수동 작업 필요) Disqus → Remark42 # 1. Disqus XML Export 2. Remark42 Admin → Import → Disqus 선택 3. XML 파일 업로드 결론 # 최종 추천 # 상황 추천 시스템 이유 개발자 블로그 Giscus 무료, GitHub 통합, Markdown 일반 블로그 (익명 필요) Cusdis 무료, 간단, 익명 익명 + 소셜 둘 다 Remark42 유연함, 모든 기능 빠른 설정 Disqus 5분 완료 (광고 감수) 완전 통제 Remark42 셀프 호스팅, 커스터마이징 개인 추천 (0AndWild 블로그) # Giscus 사용 권장\nGitHub Pages 블로그에 완벽히 어울림 기술 블로그는 GitHub 사용자가 주 독자 무료, 간단, 유지보수 없음 대안: Remark42 (익명 댓글 원할 때)\n빠른시작 # Giscus로 시작 (10분) 사용자 피드백 수집 익명 댓글 요청 많으면 Remark42로 전환 고려 댓글 시스템은 나중에도 바꿀 수 있으니, 일단 Giscus로 시작하는 것을 강력히 권장합니다!\n","date":"2025-10-17","externalUrl":null,"permalink":"/posts/comments_guide/","section":"Posts","summary":"Giscus, Utterances, Remark42, Disqus 등 모든 댓글 시스템의 장단점과 구현 방법","title":"Hugo \u0026 GithubPages 블로그 댓글 시스템 구현 가이드","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/static-site/","section":"Tags","summary":"","title":"Static Site","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/automation/","section":"Tags","summary":"","title":"Automation","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/email/","section":"Tags","summary":"","title":"Email","type":"tags"},{"content":" 개요 # 정적 사이트 생성기(Hugo)로 만든 블로그에 구독 및 이메일 알림 기능을 추가하는 방법을 분석합니다. 특히 키워드 기반 선택적 알림 기능 구현까지 다룹니다.\n1. RSS Feed + 이메일 서비스 # 개념 # Hugo의 기본 RSS Feed를 이메일로 변환하는 서비스를 활용하는 방식입니다.\n방법 A: Blogtrottr # 동작 방식 # 1. Hugo가 자동 생성한 RSS Feed (index.xml) ↓ 2. 사용자가 Blogtrottr에 RSS URL 등록 ↓ 3. Blogtrottr가 주기적으로 RSS 확인 ↓ 4. 새 글 감지 시 이메일 발송 장점 # ✅ 개발자 작업 없음 (링크만 제공) ✅ 완전 무료 ✅ 즉시 사용 가능 ✅ 서버 없이 동작 단점 # ❌ 구독자 관리 불가 ❌ 이메일 디자인 커스텀 불가 ❌ 통계 없음 ❌ 키워드 필터링 불가 ❌ 사용자가 직접 외부 사이트에서 등록해야 함 구현 난이도 # ⭐ (1/5) - 가장 쉬움\n사용 예시 # 블로그에 링크 추가: [이메일로 구독하기](https://blogtrottr.com) (사이트에서 https://0andwild.github.io/index.xml 입력) 방법 B: FeedBurner (Google) # 동작 방식 # 1. FeedBurner에 RSS Feed 등록 ↓ 2. FeedBurner가 RSS를 프록시/관리 ↓ 3. 구독 폼을 블로그에 삽입 ↓ 4. 사용자가 블로그에서 직접 구독 ↓ 5. 새 글 발행 시 자동 이메일 발송 장점 # ✅ 기본 통계 제공 ✅ 구독 폼 제공 ✅ 무료 ✅ RSS 관리 기능 단점 # ❌ Google의 지원 중단 가능성 (업데이트 중단됨) ❌ 키워드 필터링 불가 ❌ 커스텀 제한적 ❌ 오래된 UI 구현 난이도 # ⭐⭐ (2/5)\n2. Mailchimp + RSS Campaign (추천) # 개념 # 전문 이메일 마케팅 플랫폼을 활용하여 RSS Feed를 자동으로 이메일로 변환\n동작 방식 # 1. Mailchimp에 RSS Campaign 생성 ↓ 2. RSS URL 등록 및 체크 주기 설정 (일/주/월) ↓ 3. 블로그에 Mailchimp 구독 폼 삽입 ↓ 4. 사용자가 이메일 입력하여 구독 ↓ 5. 새 글 감지 시 자동으로 이메일 템플릿 생성 ↓ 6. 전체 구독자에게 발송 장점 # ✅ 무료 티어: 2,000명 구독자까지 ✅ 전문적인 이메일 디자인 (드래그 앤 드롭 에디터) ✅ 구독자 관리 (추가/삭제/세그먼트) ✅ 상세한 통계 (오픈율, 클릭율, 구독 해지율) ✅ 구독 폼 자동 생성 (임베드 코드 제공) ✅ 자동화 (새 글만 발송) ✅ 모바일 최적화 ✅ 스팸 필터 회피 (전문 발송 서버) 단점 # ❌ 키워드 필터링 기본 미지원 (Pro 플랜에서 태그별 세그먼트 가능) ❌ 무료 티어에서 Mailchimp 로고 표시 ❌ 2,000명 초과 시 유료 ($13/월~) 구현 난이도 # ⭐⭐ (2/5)\n설정 단계 # 1. Mailchimp 계정 생성 2. Audience 생성 3. Campaign → Create → Email → RSS Campaign 4. RSS URL 입력: https://your-blog.com/index.xml 5. 발송 주기 설정 (Daily/Weekly) 6. 이메일 템플릿 디자인 7. 구독 폼 코드 복사 8. Hugo에 삽입 (layouts/partials/subscribe.html) 블로그 삽입 코드 예시 # \u0026lt;!-- Mailchimp 구독 폼 --\u0026gt; \u0026lt;div id=\u0026#34;mc_embed_signup\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;https://your-mailchimp-url.com/subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;EMAIL\u0026#34; placeholder=\u0026#34;이메일 주소\u0026#34; required\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;구독하기\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 3. Buttondown (개발자 친화적, 추천) # 개념 # Markdown 기반의 뉴스레터 플랫폼으로, API를 통한 커스터마이징이 가능\n동작 방식 # 1. Buttondown에 RSS Feed 연동 ↓ 2. 자동으로 RSS 항목을 Markdown 이메일로 변환 ↓ 3. 구독자가 태그/키워드 선택 가능 ↓ 4. API를 통해 특정 태그 구독자만 필터링 가능 ↓ 5. 매칭되는 구독자에게만 발송 장점 # ✅ 무료 티어: 1,000명까지 ✅ Markdown 기반 (개발자 친화적) ✅ 강력한 API (커스텀 가능) ✅ 태그 기반 구독 (키워드 필터링 구현 가능) ✅ 광고 없음 ✅ 깔끔한 UI ✅ RSS import 자동화 ✅ 프라이버시 중심 단점 # ❌ 이메일 디자인이 단순 (Markdown만) ❌ 통계 기능이 Mailchimp보다 약함 ❌ 한국어 지원 부족 구현 난이도 # ⭐⭐⭐ (3/5) - API 사용 시 난이도 증가\n키워드 알림 구현 예시 # 1단계: 구독 폼에 태그 선택 추가 # \u0026lt;form action=\u0026#34;https://buttondown.email/api/emails/embed-subscribe/YOUR_ID\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34; placeholder=\u0026#34;이메일\u0026#34; required\u0026gt; \u0026lt;label\u0026gt;관심 주제 선택:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;tags\u0026#34; value=\u0026#34;kubernetes\u0026#34;\u0026gt; Kubernetes \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;tags\u0026#34; value=\u0026#34;docker\u0026#34;\u0026gt; Docker \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;tags\u0026#34; value=\u0026#34;golang\u0026#34;\u0026gt; Go \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;구독하기\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 2단계: GitHub Actions로 선택적 발송 # name: Send Newsletter on: push: paths: - \u0026#39;content/posts/**\u0026#39; jobs: send: runs-on: ubuntu-latest steps: - name: Extract tags from post run: | TAGS=$(grep \u0026#34;^tags = \u0026#34; content/posts/*/index.md | cut -d\u0026#39;\u0026#34;\u0026#39; -f2) echo \u0026#34;POST_TAGS=$TAGS\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV - name: Send to matching subscribers run: | curl -X POST https://api.buttondown.email/v1/emails \\ -H \u0026#34;Authorization: Token ${{ secrets.BUTTONDOWN_API_KEY }}\u0026#34; \\ -d \u0026#34;subject=New Post\u0026#34; \\ -d \u0026#34;body=...\u0026#34; \\ -d \u0026#34;tag=$POST_TAGS\u0026#34; 4. SendGrid + GitHub Actions (완전 커스텀) # 개념 # 이메일 발송 API와 CI/CD를 결합하여 완전히 커스터마이징된 알림 시스템 구축\n동작 방식 # 1. 새 글 작성 후 Git Push ↓ 2. GitHub Actions 트리거 ↓ 3. Action에서 Front Matter 파싱 - 글 제목, 요약, 태그 추출 ↓ 4. 구독자 DB 조회 (Supabase/JSON 파일) - 각 구독자의 관심 키워드와 매칭 ↓ 5. 매칭되는 구독자만 필터링 ↓ 6. SendGrid API로 개별 이메일 발송 장점 # ✅ 완전한 통제 (모든 로직 커스터마이징) ✅ 키워드 알림 완벽 구현 ✅ 무료 티어: SendGrid 월 100통 ✅ 자동화 (Git push만 하면 됨) ✅ 확장 가능 (DB, 로직 자유롭게) ✅ 구독자 데이터 소유 단점 # ❌ 개발 작업 필요 ❌ 유지보수 부담 ❌ SendGrid 무료 티어 제한적 (월 100통) ❌ 구독 폼, DB 직접 구현 필요 ❌ 스팸 필터 회피 설정 필요 구현 난이도 # ⭐⭐⭐⭐⭐ (5/5) - 가장 복잡\n아키텍처 # 구독자 데이터베이스 옵션 # 옵션 A: JSON 파일 (간단)\n// subscribers.json (GitHub 저장소에 암호화하여 저장) [ { \u0026#34;email\u0026#34;: \u0026#34;user@example.com\u0026#34;, \u0026#34;keywords\u0026#34;: [\u0026#34;kubernetes\u0026#34;, \u0026#34;docker\u0026#34;], \u0026#34;active\u0026#34;: true }, { \u0026#34;email\u0026#34;: \u0026#34;dev@example.com\u0026#34;, \u0026#34;keywords\u0026#34;: [\u0026#34;golang\u0026#34;, \u0026#34;rust\u0026#34;], \u0026#34;active\u0026#34;: true } ] 옵션 B: Supabase (권장)\n-- subscribers 테이블 CREATE TABLE subscribers ( id UUID PRIMARY KEY, email TEXT UNIQUE NOT NULL, keywords TEXT[], -- 배열 형태 active BOOLEAN DEFAULT true, created_at TIMESTAMP DEFAULT NOW() ); GitHub Actions 워크플로우 # name: Email Notification on: push: branches: [main] paths: - \u0026#39;content/posts/**\u0026#39; jobs: notify: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Setup Node.js uses: actions/setup-node@v3 with: node-version: \u0026#39;18\u0026#39; - name: Extract Post Metadata id: metadata run: | # 가장 최근 수정된 포스트 찾기 POST_FILE=$(git diff-tree --no-commit-id --name-only -r ${{ github.sha }} | grep \u0026#39;content/posts\u0026#39; | head -1) # Front Matter 파싱 TITLE=$(grep \u0026#34;^title = \u0026#34; $POST_FILE | cut -d\u0026#39;\u0026#34;\u0026#39; -f2) TAGS=$(grep \u0026#34;^tags = \u0026#34; $POST_FILE | sed \u0026#39;s/tags = \\[//;s/\\]//;s/\u0026#34;//g\u0026#39;) SUMMARY=$(grep \u0026#34;^summary = \u0026#34; $POST_FILE | cut -d\u0026#39;\u0026#34;\u0026#39; -f2) URL=\u0026#34;https://0andwild.github.io/$(dirname $POST_FILE | sed \u0026#39;s/content\\///\u0026#39;)\u0026#34; echo \u0026#34;title=$TITLE\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#34;tags=$TAGS\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#34;summary=$SUMMARY\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#34;url=$URL\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT - name: Query Matching Subscribers id: subscribers run: | # Supabase에서 매칭되는 구독자 조회 curl -X POST https://YOUR_PROJECT.supabase.co/rest/v1/rpc/get_matching_subscribers \\ -H \u0026#34;apikey: ${{ secrets.SUPABASE_KEY }}\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#34;{\\\u0026#34;post_tags\\\u0026#34;: \\\u0026#34;${{ steps.metadata.outputs.tags }}\\\u0026#34;}\u0026#34; \\ \u0026gt; subscribers.json - name: Send Emails via SendGrid run: | # Node.js 스크립트 실행 cat \u0026gt; send-emails.js \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; const sgMail = require(\u0026#39;@sendgrid/mail\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); sgMail.setApiKey(process.env.SENDGRID_API_KEY); const subscribers = JSON.parse(fs.readFileSync(\u0026#39;subscribers.json\u0026#39;)); const title = process.env.POST_TITLE; const summary = process.env.POST_SUMMARY; const url = process.env.POST_URL; subscribers.forEach(async (subscriber) =\u0026gt; { const msg = { to: subscriber.email, from: \u0026#39;noreply@0andwild.github.io\u0026#39;, subject: `새 글: ${title}`, html: ` \u0026lt;h2\u0026gt;${title}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;${summary}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;관심 키워드와 일치: ${subscriber.matched_keywords.join(\u0026#39;, \u0026#39;)}\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;${url}\u0026#34;\u0026gt;글 읽기\u0026lt;/a\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;small\u0026gt;\u0026lt;a href=\u0026#34;https://0andwild.github.io/unsubscribe?token=${subscriber.token}\u0026#34;\u0026gt;구독 취소\u0026lt;/a\u0026gt;\u0026lt;/small\u0026gt; ` }; await sgMail.send(msg); console.log(`Email sent to ${subscriber.email}`); }); EOF npm install @sendgrid/mail node send-emails.js env: SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }} POST_TITLE: ${{ steps.metadata.outputs.title }} POST_SUMMARY: ${{ steps.metadata.outputs.summary }} POST_URL: ${{ steps.metadata.outputs.url }} 구독 폼 구현 (Hugo Shortcode) # \u0026lt;!-- layouts/shortcodes/subscribe.html --\u0026gt; \u0026lt;div class=\u0026#34;subscription-form\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;블로그 구독하기\u0026lt;/h3\u0026gt; \u0026lt;form id=\u0026#34;subscribe-form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; placeholder=\u0026#34;이메일 주소\u0026#34; required\u0026gt; \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;관심 주제 선택 (선택한 주제의 글만 알림)\u0026lt;/legend\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;kubernetes\u0026#34;\u0026gt; Kubernetes\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;docker\u0026#34;\u0026gt; Docker\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;golang\u0026#34;\u0026gt; Go\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;rust\u0026#34;\u0026gt; Rust\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;devops\u0026#34;\u0026gt; DevOps\u0026lt;/label\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;구독하기\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#39;subscribe-form\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, async (e) =\u0026gt; { e.preventDefault(); const email = document.getElementById(\u0026#39;email\u0026#39;).value; const keywords = Array.from(document.querySelectorAll(\u0026#39;input[name=\u0026#34;keywords\u0026#34;]:checked\u0026#39;)) .map(cb =\u0026gt; cb.value); // Supabase에 저장 const response = await fetch(\u0026#39;https://YOUR_PROJECT.supabase.co/rest/v1/subscribers\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;apikey\u0026#39;: \u0026#39;YOUR_ANON_KEY\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ email, keywords, active: true }) }); if (response.ok) { alert(\u0026#39;구독이 완료되었습니다!\u0026#39;); } else { alert(\u0026#39;오류가 발생했습니다.\u0026#39;); } }); \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; Supabase 함수 (키워드 매칭) # -- 매칭되는 구독자를 찾는 함수 CREATE OR REPLACE FUNCTION get_matching_subscribers(post_tags TEXT) RETURNS TABLE(email TEXT, matched_keywords TEXT[], token TEXT) AS $$ BEGIN RETURN QUERY SELECT s.email, ARRAY( SELECT unnest(s.keywords) INTERSECT SELECT unnest(string_to_array(post_tags, \u0026#39;,\u0026#39;)) ) as matched_keywords, s.unsubscribe_token as token FROM subscribers s WHERE s.active = true AND s.keywords \u0026amp;\u0026amp; string_to_array(post_tags, \u0026#39;,\u0026#39;) -- 배열 겹침 연산자 ; END; $$ LANGUAGE plpgsql; 비용 분석 # SendGrid: 월 100통 무료 (이후 $19.95/월) Supabase: 월 500MB DB, 2GB 전송 무료 GitHub Actions: 월 2,000분 무료 총 비용: 완전 무료 (소규모 블로그) 5. 완전 커스텀 (Supabase + GitHub Actions + Resend) # SendGrid 대안: Resend # SendGrid보다 개발자 친화적인 최신 이메일 API\n장점 # ✅ 무료 티어: 월 3,000통 (SendGrid의 30배!) ✅ 더 간단한 API ✅ React Email 지원 (JSX로 이메일 작성) ✅ 더 나은 개발자 경험 Resend 사용 예시 # import { Resend } from \u0026#39;resend\u0026#39;; const resend = new Resend(process.env.RESEND_API_KEY); await resend.emails.send({ from: \u0026#39;blog@0andwild.github.io\u0026#39;, to: subscriber.email, subject: `새 글: ${title}`, html: `\u0026lt;p\u0026gt;${summary}\u0026lt;/p\u0026gt;\u0026lt;a href=\u0026#34;${url}\u0026#34;\u0026gt;읽기\u0026lt;/a\u0026gt;` }); 비교표 # 방법 무료 한도 키워드 알림 난이도 구독자 관리 커스텀 추천 Blogtrottr 무제한 ❌ ⭐ ❌ ❌ 테스트용 FeedBurner 무제한 ❌ ⭐⭐ ⚠️ ⚠️ 비추천 (지원 중단) Mailchimp 2,000명 ⚠️ (Pro) ⭐⭐ ✅ ⚠️ 일반 구독용 Buttondown 1,000명 ✅ ⭐⭐⭐ ✅ ✅ 개발자용 SendGrid + Actions 100통/월 ✅ ⭐⭐⭐⭐⭐ ✅ ✅✅ 고급 사용자 Resend + Actions 3,000통/월 ✅ ⭐⭐⭐⭐⭐ ✅ ✅✅ 완벽한 통제 추천 로드맵 # 단계 1: 빠른 시작 (즉시) # Mailchimp RSS Campaign\n10분 설정 전체 구독자에게 모든 글 알림 단계 2: 개선 (1주 후) # Buttondown으로 마이그레이션\n더 깔끔한 경험 기본 태그 기능 단계 3: 고급 기능 (필요 시) # Resend + GitHub Actions + Supabase\n키워드 기반 선택적 알림 완전한 통제 확장 가능성 결론 # 일반 블로거라면: # → Mailchimp (가장 쉽고 전문적)\n개발자 블로그라면: # → Buttondown (개발자 친화적, API 제공)\n키워드 알림이 필수라면: # → Resend + GitHub Actions + Supabase (완전 커스텀)\n돈 안 쓰고 테스트하려면: # → Blogtrottr (30초 설정)\n빠른시작 # 실제 구현을 원하신다면:\nMailchimp로 시작 (학습 곡선 낮음) 트래픽 증가 시 Buttondown 고려 고급 기능 필요 시 커스텀 솔루션 구축 키워드 알림은 초기엔 과한 기능일 수 있으니, 기본 구독부터 시작하는 것을 권장합니다.\n","date":"2025-10-17","externalUrl":null,"permalink":"/posts/subscription_alert/","section":"Posts","summary":"RSS Feed, Mailchimp, Buttondown, 커스텀 솔루션까지 - 블로그 구독 시스템의 모든 것","title":"Hugo \u0026 GithubPages 블로그 구독 및 이메일 알림 시스템 구현 가이드","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/rss/","section":"Tags","summary":"","title":"RSS","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/subscription/","section":"Tags","summary":"","title":"Subscription","type":"tags"},{"content":"","date":"2025-10-16","externalUrl":null,"permalink":"/categories/blowfish/","section":"Categories","summary":"","title":"Blowfish","type":"categories"},{"content":"","date":"2025-10-16","externalUrl":null,"permalink":"/series/blowfish/","section":"Series","summary":"","title":"Blowfish","type":"series"},{"content":" 제목 (H2) # 소제목 (H3) # 일반 텍스트입니다. 굵게, 기울임, 취소선\n이미지 삽입 # 방법 1: 로컬 이미지 # 포스트 폴더 내에 이미지 파일을 넣고 사용:\n![이미지 설명](image.jpg) 방법 2: 외부 이미지 URL # ![이미지 설명](https://example.com/image.jpg) 방법 3: HTML 태그 (크기 조정 가능) # \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;이미지 설명\u0026#34; width=\u0026#34;500\u0026#34; /\u0026gt; 캐러셀 이미지 (슬라이드 효과) # 16:9 # Previous Next 21:9 Previous Next # 코드 삽입 # 인라인 코드 # inline code 형식으로 작성\n코드 블록 # package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } def hello(): print(\u0026#34;Hello, World!\u0026#34;) docker run -d -p 8080:80 nginx 링크 # 기본 링크 # 링크 텍스트\n참조 스타일 링크 # 링크 텍스트\narticle 참조 # 리스트 # 순서 없는 리스트 # 항목 1 항목 2 하위 항목 2-1 하위 항목 2-2 항목 3 순서 있는 리스트 # 첫 번째 두 번째 세 번째 체크리스트 # 할 일 1 완료된 일 할 일 2 인용문 # 인용문 내용입니다. 여러 줄도 가능합니다.\n표 (Table) # 항목 설명 비고 A 설명 A 비고 A B 설명 B 비고 B 링크 임베드 (Shortcodes) # YouTube 영상 # {{\u0026lt; youtube VIDEO_ID \u0026gt;}}\nTwitter/X # {{\u0026lt; twitter user=\u0026ldquo;username\u0026rdquo; id=\u0026ldquo;tweet_id\u0026rdquo; \u0026gt;}}\nGitHub Gist # {{\u0026lt; gist username gist_id \u0026gt;}}\n알림 박스 (Blowfish Alert) # {{\u0026lt; alert \u0026ldquo;circle-info\u0026rdquo; \u0026gt;}} 정보 알림입니다. {{\u0026lt; /alert \u0026gt;}}\n{{\u0026lt; alert \u0026ldquo;lightbulb\u0026rdquo; \u0026gt;}} 팁이나 아이디어입니다. {{\u0026lt; /alert \u0026gt;}}\n{{\u0026lt; alert \u0026ldquo;triangle-exclamation\u0026rdquo; \u0026gt;}} 경고 메시지입니다. {{\u0026lt; /alert \u0026gt;}}\n접기/펼치기 (Details) # 클릭하여 펼치기 숨겨진 내용이 여기에 표시됩니다.\n주석 # 수평선 # 위아래로 구분선을 만들 때 사용:\n각주 # 텍스트에 각주1를 추가할 수 있습니다.\n그래프 차트 # Mermaid 차트 # graph LR; A[Lemons]--\u003eB[Lemonade]; B--\u003eC[Profit] Swatched (color showcase) # TypeLt # (Ex1)\n(Ex2)\n(Ex3)\nYoutube Lite # 작성 팁:\nFront matter의 draft: true를 false로 변경하면 배포됩니다 description과 summary를 작성하면 SEO에 도움이 됩니다 이미지는 포스트 폴더에 함께 넣는 것을 권장합니다 각주 내용입니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-16","externalUrl":null,"permalink":"/posts/blowfish_markdown/","section":"Posts","summary":"Blowfish 마크다운 문법 설명서","title":"Hugo markdown 설명서","type":"posts"},{"content":"","date":"2025-10-16","externalUrl":null,"permalink":"/tags/markdown/","section":"Tags","summary":"","title":"Markdown","type":"tags"},{"content":"","date":"2025-10-16","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 블로그 소개 0AndWild Tech Blog에 오신 것을 환영합니다! 이곳은 백엔드 개발, 인프라, 그리고 다양한 기술에 대한 생각과 경험, 배움을 공유하는 공간입니다.\n저는 누구인가요? 3년차 백엔드 개발자로, 새로운 기술을 탐구하고 복잡한 문제를 해결하는 것을 좋아합니다.\n저의 가치관 시간이 걸려도 문제점을 해결했을 때 성취감을 느낍니다. 소통하는 것을 좋아하고 배운 것을 공유할 때 즐거움을 느낍니다. 너무 안정적인 것을 추구하기보다 새로운 길을 개척해나가는 것을 좋아합니다. 실패를 두려워하지 않고 경험이라 생각합니다. 이 블로그에서 다루는 내용 백엔드 개발: 백엔드 아키텍처, 패턴, 모범 사례에 대한 심층 탐구 인프라: DevOps, Docker, Kubernetes, 클라우드 기술 기술 탐험: 새로운 도구와 프레임워크에 대한 실습 경험 연락하기 GitHub: 0AndWild LinkedIn: 박건영 Email: parkky3563@gmail.com 방문해 주셔서 감사합니다! 🚀\n","date":"2025-10-16","externalUrl":null,"permalink":"/about/","section":"0AndWild_log","summary":"\u003ch1 class=\"relative group\"\u003e블로그 소개\n    \u003cdiv id=\"블로그-소개\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e0AndWild Tech Blog\u003c/strong\u003e에 오신 것을 환영합니다! 이곳은 백엔드 개발, 인프라, 그리고 다양한 기술에 대한 생각과 경험, 배움을 공유하는 공간입니다.\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003e저는 누구인가요?\n    \u003cdiv id=\"저는-누구인가요\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003e3년차 백엔드 개발자로, 새로운 기술을 탐구하고 복잡한 문제를 해결하는 것을 좋아합니다.\u003c/p\u003e\n\n\u003ch3 class=\"relative group\"\u003e저의 가치관\n    \u003cdiv id=\"저의-가치관\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e시간이 걸려도 문제점을 해결했을 때 성취감을 느낍니다.\u003c/li\u003e\n\u003cli\u003e소통하는 것을 좋아하고 배운 것을 공유할 때 즐거움을 느낍니다.\u003c/li\u003e\n\u003cli\u003e너무 안정적인 것을 추구하기보다 새로운 길을 개척해나가는 것을 좋아합니다.\u003c/li\u003e\n\u003cli\u003e실패를 두려워하지 않고 경험이라 생각합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 class=\"relative group\"\u003e이 블로그에서 다루는 내용\n    \u003cdiv id=\"이-블로그에서-다루는-내용\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e백엔드 개발\u003c/strong\u003e: 백엔드 아키텍처, 패턴, 모범 사례에 대한 심층 탐구\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인프라\u003c/strong\u003e: DevOps, Docker, Kubernetes, 클라우드 기술\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기술 탐험\u003c/strong\u003e: 새로운 도구와 프레임워크에 대한 실습 경험\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 class=\"relative group\"\u003e연락하기\n    \u003cdiv id=\"연락하기\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub: \u003ca\n  href=\"https://github.com/0AndWild\"\n    target=\"_blank\"\n  \u003e0AndWild\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLinkedIn: \u003ca\n  href=\"https://linkedin.com/in/%ea%b1%b4%ec%98%81-%eb%b0%95-158861275\"\n    target=\"_blank\"\n  \u003e박건영\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eEmail: \u003ca\n  href=\"mailto:parkky3563@gmail.com\"\u003eparkky3563@gmail.com\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e방문해 주셔서 감사합니다! 🚀\u003c/p\u003e","title":"소개","type":"page"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/tags/oop/","section":"Tags","summary":"","title":"OOP","type":"tags"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/categories/programming/","section":"Categories","summary":"","title":"Programming","type":"categories"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/series/programming-basics/","section":"Series","summary":"","title":"Programming Basics","type":"series"},{"content":" 객체지향(OOP)과 절차적 프로그래밍(PP) # 객체지향언어와 절차지향언어는 절대 반대되는 개념이 아니다. 그렇다면 객체지향언어와 절차지향언어는 무엇인가?\n우리는 보통 Java, Python, C# 등의 언어를 객체지향 언어라고 부르며 C언어는 절차지향언어라고 부른다. 하지만 어디까지나 이 언어들이 지향하는 것이지 C언어는 절차적 프로그래밍만 가능하고 Java나 Python 등은 객체적 프로그래밍만 가능하다는 것이 아니다.\n어떤 언어를 사용하든 상관없이 절차지향적 프로그래밍을 할 수 있다. 반대로 C언어를 사용하더라도 객체지향적으로 코딩을 할 수 있는 것이다.\n\u0026lsquo;절차지향\u0026rsquo;이라는 용어의 오해 # 사실 절차지향적 언어라 하는 것은 잘못된 것이다. 모든 프로그래밍 언어가 절차를 기반으로 두고 있는데 절차를 지향한다는 말은 앞뒤가 맞지 않는다.\n하나의 예를 비유하자면:\n역도라는 스포츠는 바벨을 이용한 운동을 기반으로 하는 것인데 바벨을 지향하는 스포츠라고 하는 것과 같은 맥락이다. 그럼 역도를 덤벨로 해야 하나\u0026hellip;? 다시 말해 절차지향이 아닌 절차적 프로그래밍이 맞는 것이다.\n객체지향 프로그래밍(OOP)와 절차적 프로그래밍(PP)는 어디까지나 프로그래밍을 하는데 있어 접근 방식의 차이가 있을 뿐 반대 개념은 아니다! 핵심 차이점 # 절차적 프로그래밍: 데이터를 중심으로 함수를 만들어 사용 객체지향 프로그래밍: 데이터와 기능(함수)들을 묶어 하나의 객체로 만들어 사용 절차적 언어와 객체지향언어를 구분하는 기준 # 여러가지 방식이 있겠지만 큰 틀에서는 아래와 같이 나뉜다.\n캡슐화, 다형성, 클래스 상속을 지원하는가? 데이터 접근 제한을 걸 수 있는가? 대게 위 기준을 만족하면 객체지향 성향이 강해진다고 보면 된다.\n절차적 프로그래밍 # 절차적 프로그래밍은 말 그대로 절차적으로 코드를 구성한다는 것이다.\n데이터에 대한 순서를 파악하고 필요한 기능을 함수로 만들어 절차적(순서대로) 진행시키는 방식\n객체지향 프로그래밍 # 객체지향 프로그래밍의 경우 기능들을 묶어 하나의 객체로 만든다.\n다시 말하면 각각의 객체를 생성하고 그 객체마다 할 수 있는 행위(기능)들과 데이터를 하나로 묶어주는 것이다.\n예시 # 자동차 호출 서비스를 구현한다고 가정해보자:\n자동차 객체: 자동차가 할 수 있는 행위(기능)를 하나로 묶음 기사 객체: 기사가 할 수 있는 행위를 묶음 승객 객체: 승객이 할 수 있는 행위를 묶음 각 객체의 메소드나 필드를 호출하면서 서로 간의 상호작용을 통해 알고리즘을 구성하는 방식이다.\n그럼 어떤 방식이 더 좋은가? # 정답은 없다. 필요에 맞게 사용을 하고 자신이 선호하는 스타일을 사용하면 된다. 과거의 프로그래밍 # 과거에는 현재처럼 큰 규모의 하드웨어와 소프트웨어가 필요치 않았다. 오래된 언어인 C, 포트란, 코볼 같은 절차적 언어의 대표라 할 수 있는 언어들이 사용되어졌다.\n현대의 프로그래밍 # 현대에 들어서면서 점점 소프트웨어 발전이 빨라졌고 이에 따라 코드들도 복잡해져갔다.\n그러다 보니 복잡한 알고리즘들이 꼬이기 시작했고 작성한 코드를 사람이 읽었을 때 이해하기 힘들거나 이해할 수 없는 스파게티 코드가 되어버린 것이다.\n이러한 문제의 대안으로 객체지향적 프로그래밍이 나온 것이다.\n왜 객체지향이 우세한가? # 다만 현재 기준 객체지향 프로그래밍이 우세하게 사용되어지고는 있다. 그 이유는:\n복잡한 프로그래밍일수록 절차적 프로그래밍을 사용한다면 코드들이 꼬이기 쉽다 확장성 측면에서도 유지 보수를 할 때 메리트가 떨어진다 절차적 프로그래밍 장단점 # 장점 # 객체나 클래스 생성 없이 바로 프로그래밍 필요한 기능을 함수로 만들어 복붙하지 않고 호출하여 사용 프로그램 흐름을 쉽게 추적 단점 # 각 코드들의 끈끈한 우정 때문에 수정이 힘들다 (유기성이 높아 추가, 수정이 힘듦) 디버그(오류검사)가 힘듦 객체지향 프로그래밍 장단점 # 장점 # 모듈화, 캡슐화로 유지보수가 편함 객체지향적으로 현실 세계와 유사성에 의해 코드를 이해하기 쉽다 객체는 그 자체가 하나의 프로그램으로 다른 프로그램에서도 재사용이 가능 단점 # 대부분의 객체 지향 프로그램은 속도가 상대적으로 느려지고 많은 양의 메모리를 사용하는 경향이 있음 현실세계와 유사성에 의해 코드를 이해하기 쉽게 만들기 위해 설계 과정에 있어 많은 시간이 들어간다 정답은 없다! 적재적소에 맞추어 사용하자 # 절차적 프로그래밍을 사용하는 경우 # 보통 프로젝트 규모가 크지 않고 재사용할 일이 크지 않는 경우에 많이 사용된다.\n장점:\n프로그램 자체가 가벼워짐 객체지향으로 만드는 것보다 개발시간과 인력도 줄어듦 객체지향 프로그래밍을 사용하는 경우 # 큰 규모의 프로젝트에서 코드들을 재사용해야 한다면 초기 개발비용을 제외하고 객체지향 프로그래밍이 적합하다.\n장점:\n유지보수 측면에서 안정적 마무리 # 오늘은 이렇게 객체지향 프로그래밍과 절차적 프로그래밍에 대해 알아보았다. 아직은 깊이있는 내용에 대해서는 알지 못하지만 여러 글들을 찾아보며 객체지향과 절차적 프로그래밍에 대한 큰 틀을 이해하고 넘어가고 다음번에 좀 더 깊이있게 들어가보자 한다! ","date":"2022-08-31","externalUrl":null,"permalink":"/posts/about_oop/","section":"Posts","summary":"객체지향 프로그래밍과 절차적 프로그래밍의 개념, 차이점, 장단점을 알아보고 언제 어떤 방식을 사용해야 하는지 정리합니다.","title":"객체지향 프로그래밍과 절차적 프로그래밍에 대해 알아보자","type":"posts"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/tags/%EC%A0%88%EC%B0%A8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"절차적 프로그래밍","type":"tags"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","section":"Tags","summary":"","title":"프로그래밍 패러다임","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]
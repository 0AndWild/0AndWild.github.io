[{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/","section":"0AndWild_log","summary":"","title":"0AndWild_log","type":"page"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/categories/blog/","section":"Categories","summary":"","title":"Blog","type":"categories"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/comments/","section":"Tags","summary":"","title":"Comments","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/giscus/","section":"Tags","summary":"","title":"Giscus","type":"tags"},{"content":" Giscus란? # Giscus는 GitHub Discussions를 백엔드로 사용하는 오픈소스 댓글 시스템입니다.\n주요 특징 # ✅ 완전 무료 (GitHub 기능 활용) ✅ 서버 불필요 (GitHub이 모든 것을 처리) ✅ Markdown 완벽 지원 (코드 블록, 이미지, 표 등) ✅ 반응(Reactions) (👍, ❤️, 😄 등) ✅ GitHub 알림 (댓글 달리면 알림 받음) ✅ 다크모드 (블로그 테마와 자동 동기화) ✅ 데이터 소유 (본인 저장소에 저장) Utterances와의 차이점 # 기능 Giscus Utterances 백엔드 GitHub Discussions GitHub Issues 반응 ✅ ❌ 대댓글 ✅ (중첩) ⚠️ (flat) 댓글 정렬 ✅ ⚠️ 적합성 댓글 전용 이슈 트래킹 결론: Giscus가 Utterances의 상위 호환입니다.\n사전 준비 # 필요한 것 # GitHub 계정 Public GitHub 저장소 (블로그 저장소) Hugo + Blowfish 테마 제약사항 # ⚠️ Public 저장소만 가능 (Private 저장소는 Discussions 기능 제한) ⚠️ GitHub 계정 필요 (익명 댓글 불가) 1단계: GitHub Discussions 활성화 # 1.1 저장소 설정 페이지 이동 # GitHub에서 블로그 저장소 접속\n예: https://github.com/0AndWild/0AndWild.github.io Settings 탭 클릭\n1.2 Discussions 활성화 # 페이지를 아래로 스크롤하여 Features 섹션 찾기\nDiscussions 체크박스를 ✅ 체크\n자동으로 저장됨\n1.3 확인 # 저장소 상단에 Discussions 탭이 생성되었는지 확인\nCode | Issues | Pull requests | Discussions | ← 새로 생김! 2단계: Giscus App 설치 # 2.1 Giscus GitHub App 설치 # https://github.com/apps/giscus 접속\nInstall 버튼 클릭\n권한 선택:\nAll repositories (모든 저장소) Only select repositories (특정 저장소만 - 권장) 블로그 저장소 선택:\n0AndWild/0AndWild.github.io Install 클릭\n2.2 권한 확인 # Giscus가 요청하는 권한:\n✅ Read access to discussions (토론 읽기) ✅ Write access to discussions (토론 쓰기) ✅ Read access to metadata (메타데이터 읽기) 3단계: Giscus 설정 생성 # 3.1 Giscus 웹사이트 접속 # https://giscus.app/ko 방문\n3.2 저장소 연결 # 저장소 섹션에 입력:\n0AndWild/0AndWild.github.io 아래에 성공 메시지가 표시되어야 함:\n✅ 성공! 이 저장소는 모든 조건을 만족합니다. 만약 오류가 뜨면:\nDiscussions 활성화 확인 Giscus App 설치 확인 저장소가 Public인지 확인 3.3 페이지 ↔️ Discussion 연결 방식 # Discussion 카테고리 섹션에서 선택:\n권장: pathname (경로명) # 매핑: pathname 선택 각 블로그 포스트의 경로가 Discussion 제목이 됩니다.\n예시:\n포스트: /posts/giscus-guide/ Discussion 제목: posts/giscus-guide 대안들: # URL: 전체 URL 사용 (도메인 변경 시 문제) title: 포스트 제목 사용 (제목 변경 시 문제) og:title: OpenGraph 제목 specific term: 직접 지정 추천: pathname 사용\n3.4 Discussion 카테고리 선택 # Discussion 카테고리 드롭다운에서 선택:\n권장: Announcements # 카테고리: Announcements 선택 특징:\n관리자만 새 Discussion 생성 가능 댓글은 누구나 가능 블로그 포스트용으로 최적 대안: General # 누구나 Discussion 생성 가능 더 개방적 추천: Announcements (블로그에 적합)\n3.5 기능 선택 # 반응 활성화 # ✅ 반응 활성화 사용자가 👍, ❤️, 😄 등으로 반응 가능\n메타데이터 보내기 # □ 메타데이터 보내기 (체크 해제 권장) 불필요한 기능, 꺼두는 것이 좋음\n댓글 입력란 위치 # ⚪ 댓글 위에 ⚪ 댓글 아래 (권장) 권장: 댓글 아래\n기존 댓글을 먼저 읽고 작성하도록 유도 느긋한 로딩 # ✅ 느긋한 로딩 페이지 로딩 속도 향상 (권장)\n3.6 테마 선택 # 권장: preferred_color_scheme # 테마: preferred_color_scheme 동작:\n사용자의 시스템 설정에 따라 자동 전환 다크모드 ↔️ 라이트모드 자동 대안: # light: 항상 밝은 테마 dark: 항상 어두운 테마 transparent_dark: 투명 다크 기타 GitHub 테마들 추천: preferred_color_scheme (자동 전환)\n3.7 언어 설정 # 언어: ko (한국어) 4단계: 생성된 코드 복사 # 4.1 스크립트 복사 # 페이지 하단에 Enable giscus 섹션에서 생성된 코드 복사:\n\u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;R_kgDOxxxxxxxx\u0026#34; data-category=\u0026#34;Announcements\u0026#34; data-category-id=\u0026#34;DIC_kwDOxxxxxxxx\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; data-loading=\u0026#34;lazy\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 4.2 중요한 값들 # data-repo-id: 저장소 고유 ID (자동 생성) data-category-id: 카테고리 고유 ID (자동 생성) 이 값들은 본인의 저장소마다 다르므로, 반드시 Giscus 웹사이트에서 생성된 코드를 사용해야 합니다.\n5단계: Blowfish 테마에 통합 # 5.1 디렉토리 생성 # 터미널에서 블로그 루트 디렉토리로 이동 후:\nmkdir -p layouts/partials 5.2 comments.html 파일 생성 # touch layouts/partials/comments.html 또는 IDE/에디터에서 직접 생성:\nlayouts/ └── partials/ └── comments.html ← 새로 생성 5.3 Giscus 코드 삽입 # layouts/partials/comments.html 파일에 다음 내용 추가:\n\u0026lt;!-- Giscus 댓글 시스템 --\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;R_kgDOxxxxxxxx\u0026#34; data-category=\u0026#34;Announcements\u0026#34; data-category-id=\u0026#34;DIC_kwDOxxxxxxxx\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; data-loading=\u0026#34;lazy\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; ⚠️ 주의: 위의 data-repo-id와 data-category-id 값을 본인의 값으로 교체해야 합니다!\n5.4 params.toml 설정 # config/_default/params.toml 파일을 열고 [article] 섹션에 추가:\n[article] showComments = true # 이 줄 추가 또는 확인 # ... 기타 설정들 이미 showComments 항목이 있다면 true로 설정되어 있는지 확인하세요.\n6단계: 로컬 테스트 # 6.1 Hugo 서버 실행 # hugo server -D 6.2 브라우저에서 확인 # http://localhost:1313 포스트 페이지 하단에 Giscus 댓글 위젯이 표시되어야 합니다.\n6.3 테스트 댓글 작성 # GitHub으로 로그인 버튼 클릭 GitHub OAuth 인증 테스트 댓글 작성 댓글이 표시되는지 확인 6.4 GitHub Discussions 확인 # GitHub 저장소 → Discussions 탭 Announcements 카테고리에 새 Discussion 생성되었는지 확인 Discussion 제목이 포스트 경로인지 확인 7단계: 배포 # 7.1 Git에 커밋 # git add layouts/partials/comments.html git add config/_default/params.toml git commit -m \u0026#34;Add Giscus comments system\u0026#34; 7.2 GitHub에 푸시 # git push origin main 7.3 GitHub Actions 확인 # GitHub Actions가 자동으로 빌드 및 배포를 진행합니다.\n배포 상태 확인:\nGitHub 저장소 → Actions 탭 7.4 배포된 사이트 확인 # https://0andwild.github.io 포스트 페이지에 댓글 위젯이 정상적으로 표시되는지 확인하세요.\n고급 설정 # 다크모드 및 언어 동적 설정 (권장) # Blowfish 테마의 다크모드 토글과 언어 전환에 따라 Giscus가 자동으로 변경되도록 설정하는 완전한 방법입니다.\n완전한 동적 설정 # layouts/partials/comments.html 전체 코드:\n\u0026lt;!-- Giscus Comments with Dynamic Theme and Language --\u0026gt; {{ $lang := .Site.Language.Lang }} {{ $translationKey := .File.TranslationBaseName }} \u0026lt;script\u0026gt; (function() { // Get current theme (dark/light) function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark_tritanopia\u0026#39; : \u0026#39;light_tritanopia\u0026#39;; } // Get language from Hugo template const currentLang = \u0026#39;{{ $lang }}\u0026#39;; // Use file directory path for unified comments across languages // Example: \u0026#34;posts/subscription_alert\u0026#34; for both index.ko.md and index.en.md const discussionId = \u0026#39;{{ .File.Dir | replaceRE \u0026#34;^content/\u0026#34; \u0026#34;\u0026#34; | replaceRE \u0026#34;/$\u0026#34; \u0026#34;\u0026#34; }}\u0026#39;; // Wait for DOM to be ready if (document.readyState === \u0026#39;loading\u0026#39;) { document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, initGiscus); } else { initGiscus(); } function initGiscus() { // Create and insert Giscus script with dynamic settings const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://giscus.app/client.js\u0026#39;; script.setAttribute(\u0026#39;data-repo\u0026#39;, \u0026#39;0AndWild/0AndWild.github.io\u0026#39;); script.setAttribute(\u0026#39;data-repo-id\u0026#39;, \u0026#39;R_kgDOQAqZFA\u0026#39;); script.setAttribute(\u0026#39;data-category\u0026#39;, \u0026#39;General\u0026#39;); script.setAttribute(\u0026#39;data-category-id\u0026#39;, \u0026#39;DIC_kwDOQAqZFM4CwwRg\u0026#39;); script.setAttribute(\u0026#39;data-mapping\u0026#39;, \u0026#39;specific\u0026#39;); script.setAttribute(\u0026#39;data-term\u0026#39;, discussionId); script.setAttribute(\u0026#39;data-strict\u0026#39;, \u0026#39;0\u0026#39;); script.setAttribute(\u0026#39;data-reactions-enabled\u0026#39;, \u0026#39;1\u0026#39;); script.setAttribute(\u0026#39;data-emit-metadata\u0026#39;, \u0026#39;0\u0026#39;); script.setAttribute(\u0026#39;data-input-position\u0026#39;, \u0026#39;bottom\u0026#39;); script.setAttribute(\u0026#39;data-theme\u0026#39;, getGiscusTheme()); script.setAttribute(\u0026#39;data-lang\u0026#39;, currentLang); script.setAttribute(\u0026#39;data-loading\u0026#39;, \u0026#39;lazy\u0026#39;); script.setAttribute(\u0026#39;crossorigin\u0026#39;, \u0026#39;anonymous\u0026#39;); script.async = true; // Find giscus container or create one const container = document.querySelector(\u0026#39;.giscus-container\u0026#39;) || document.currentScript?.parentElement; if (container) { container.appendChild(script); } } // Monitor theme changes and update Giscus function updateGiscusTheme() { const iframe = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); if (!iframe) return; const theme = getGiscusTheme(); try { iframe.contentWindow.postMessage( { giscus: { setConfig: { theme: theme } } }, \u0026#39;https://giscus.app\u0026#39; ); } catch (error) { console.log(\u0026#39;Giscus theme update delayed, will retry...\u0026#39;); } } // Watch for theme changes using MutationObserver const observer = new MutationObserver((mutations) =\u0026gt; { mutations.forEach((mutation) =\u0026gt; { if (mutation.attributeName === \u0026#39;class\u0026#39;) { // Delay update to ensure iframe is ready setTimeout(updateGiscusTheme, 100); } }); }); // Start observing after a short delay setTimeout(() =\u0026gt; { observer.observe(document.documentElement, { attributes: true, attributeFilter: [\u0026#39;class\u0026#39;] }); }, 500); // Update theme when Giscus iframe loads window.addEventListener(\u0026#39;message\u0026#39;, (event) =\u0026gt; { if (event.origin !== \u0026#39;https://giscus.app\u0026#39;) return; if (event.data.giscus) { // Giscus is ready, update theme setTimeout(updateGiscusTheme, 200); } }); })(); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* Ensure Giscus iframe has proper height and displays all content */ .giscus-container { min-height: 300px; } .giscus-container iframe.giscus-frame { width: 100%; border: none; min-height: 300px; } /* Make sure comment actions are visible */ .giscus { overflow: visible !important; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;giscus-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 동작 방식 설명 # 1. 언어 동적 설정 # {{ $lang := .Site.Language.Lang }} const currentLang = \u0026#39;{{ $lang }}\u0026#39;; Hugo 템플릿에서 현재 페이지 언어 가져오기 한국어 페이지: ko, 영어 페이지: en Giscus에 해당 언어로 설정 결과:\n한국어 페이지 → Giscus UI가 한국어로 표시 영어 페이지 → Giscus UI가 영어로 표시 언어 전환 시 페이지 리로드되면서 자동으로 변경 2. 다크모드 동적 설정 # function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark_tritanopia\u0026#39; : \u0026#39;light_tritanopia\u0026#39;; } Blowfish 테마는 다크모드 시 \u0026lt;html class=\u0026quot;dark\u0026quot;\u0026gt; 추가 이를 감지하여 테마 결정 dark_tritanopia / light_tritanopia 테마 사용 (색맹 친화적) 결과:\n페이지 로드 시: 현재 테마 상태로 Giscus 로드 다크모드 토글 클릭 시: 실시간으로 Giscus 테마 변경 3. 언어별 댓글 통합 # const discussionId = \u0026#39;{{ .File.Dir | replaceRE \u0026#34;^content/\u0026#34; \u0026#34;\u0026#34; | replaceRE \u0026#34;/$\u0026#34; \u0026#34;\u0026#34; }}\u0026#39;; 파일 디렉토리 경로를 Discussion ID로 사용 content/posts/subscription_alert/index.ko.md → posts/subscription_alert content/posts/subscription_alert/index.en.md → posts/subscription_alert 같은 ID이므로 한국어/영어 버전이 같은 댓글 공유 결과:\n한국어 포스트에서 작성한 댓글 영어 포스트에서도 동일하게 표시 포스트별로는 별도 Discussion 생성 4. 실시간 테마 변경 감지 # const observer = new MutationObserver((mutations) =\u0026gt; { mutations.forEach((mutation) =\u0026gt; { if (mutation.attributeName === \u0026#39;class\u0026#39;) { setTimeout(updateGiscusTheme, 100); } }); }); MutationObserver로 HTML 클래스 변경 감지 다크모드 토글 클릭 시 즉시 감지 postMessage로 Giscus iframe에 테마 변경 명령 전송 테스트 방법 # # 1. 로컬 서버 실행 hugo server -D # 2. 브라우저에서 확인 http://localhost:1313/posts/subscription_alert/ 테스트 항목:\n✅ 페이지 로드 시 현재 테마(라이트/다크)로 Giscus 표시 ✅ 다크모드 토글 클릭 시 Giscus 테마 즉시 변경 ✅ 언어 전환 (ko → en) 시 Giscus 언어 변경 ✅ 한국어/영어 페이지에서 같은 댓글 표시 테마 옵션 변경 # 다른 테마를 사용하려면 getGiscusTheme() 함수 수정:\n// 기본 테마 function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;; } // 고대비 테마 function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark_high_contrast\u0026#39; : \u0026#39;light_high_contrast\u0026#39;; } // GitHub 스타일 테마 function getGiscusTheme() { const isDark = document.documentElement.classList.contains(\u0026#39;dark\u0026#39;); return isDark ? \u0026#39;dark_dimmed\u0026#39; : \u0026#39;light\u0026#39;; } 사용 가능한 테마:\nlight / dark light_high_contrast / dark_high_contrast light_tritanopia / dark_tritanopia (색맹 친화적) dark_dimmed transparent_dark preferred_color_scheme (시스템 설정 따름) 정적 테마 설정 (간단한 방법) # 동적 변경이 필요 없다면 정적으로 설정 가능:\n\u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;R_kgDOxxxxxxxx\u0026#34; data-category=\u0026#34;General\u0026#34; data-category-id=\u0026#34;DIC_kwDOxxxxxxxx\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 장점: 간단함 단점: 실시간 테마 변경 불가, 언어별 댓글 분리됨\n포스트별 댓글 숨기기 # 특정 포스트에서만 댓글을 숨기려면, 해당 포스트의 front matter에:\n--- title: \u0026#34;댓글 없는 포스트\u0026#34; showComments: false # 이 포스트만 댓글 숨김 --- 카테고리별 댓글 분리 # 다른 카테고리의 포스트에 다른 Discussion 카테고리를 사용하려면:\n\u0026lt;!-- 조건부 카테고리 설정 --\u0026gt; \u0026lt;script\u0026gt; const category = {{ if in .Params.categories \u0026#34;Tutorial\u0026#34; }} \u0026#34;DIC_kwDOxxxxTutorial\u0026#34; {{ else }} \u0026#34;DIC_kwDOxxxxGeneral\u0026#34; {{ end }}; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; ... data-category-id=\u0026#34;{{ category }}\u0026#34; ...\u0026gt; \u0026lt;/script\u0026gt; 문제 해결 # 댓글 위젯이 표시되지 않음 # 원인 1: Discussions 미활성화 # 해결: GitHub 저장소 → Settings → Discussions 체크 원인 2: Giscus App 미설치 # 해결: https://github.com/apps/giscus 에서 Install 원인 3: 저장소 ID 오류 # 해결: giscus.app에서 코드 재생성 원인 4: showComments 설정 누락 # # config/_default/params.toml [article] showComments = true # 확인 로그인 버튼만 보이고 댓글 못 씀 # 원인: GitHub OAuth 승인 필요 # 1. \u0026#34;GitHub으로 로그인\u0026#34; 클릭 2. OAuth 권한 승인 3. 저장소로 리다이렉트 4. 댓글 작성 가능 댓글이 저장되지 않음 # 원인: 저장소 권한 문제 # 확인 사항: 1. 저장소가 Public인지 2. Giscus App 권한에 저장소 포함되어 있는지 3. Discussion 카테고리가 존재하는지 다크모드가 동기화 안 됨 # 해결: JavaScript 동기화 코드 추가 # 위의 \u0026ldquo;고급 설정 \u0026gt; 다크모드 자동 전환\u0026rdquo; 참고\nGiscus 관리 # 댓글 관리 # GitHub Discussions에서 관리 # 1. GitHub 저장소 → Discussions 탭 2. 해당 Discussion 클릭 3. 관리 작업: - 댓글 수정 (본인 댓글만) - 댓글 삭제 (관리자) - 사용자 차단 (관리자) - Discussion 잠금 (관리자) 스팸 댓글 처리 # 1. GitHub Discussions에서 스팸 댓글 찾기 2. 댓글 옆 ... 메뉴 → \u0026#34;Delete\u0026#34; 3. 사용자 차단: 프로필 → Block user 알림 설정 # GitHub 알림으로 댓글 알림 받기 # 1. GitHub → Settings → Notifications 2. Watching에 저장소 추가 3. 이메일로 알림 받기 설정 특정 Discussion만 알림 받기 # 1. Discussions 탭 → 해당 Discussion 2. 오른쪽 \u0026#34;Subscribe\u0026#34; 버튼 3. \u0026#34;Notify me\u0026#34; 선택 통계 및 분석 # 댓글 통계 보기 # GitHub Discussions에서:\n1. Discussions 탭 2. 카테고리별 Discussion 수 확인 3. 각 Discussion의 댓글 수 확인 GitHub Insights 활용 # GitHub 저장소 → Insights → Community → Discussions 활동 확인 비용 및 제한사항 # 비용 # 완전 무료\nGitHub 계정만 있으면 사용 가능 저장소 크기 제한 내에서 무제한 댓글 제한사항 # GitHub API Rate Limit # 시간당 60회 (미인증) 시간당 5,000회 (인증) Giscus는 캐싱으로 최적화되어 있어 문제 없음 저장소 크기 # GitHub Free: 저장소당 1GB 텍스트 댓글만으로는 제한 도달 불가능 Discussions 제한 # 없음 (무제한) 대안 비교 # Giscus vs Utterances # 항목 Giscus Utterances 백엔드 Discussions Issues 반응 ✅ ❌ 대댓글 중첩 지원 Flat 추천 ⭐⭐⭐⭐⭐ ⭐⭐⭐ 결론: Giscus 사용 권장\nGiscus vs Disqus # 항목 Giscus Disqus 비용 무료 무료 (광고) 광고 ❌ ✅ 익명 댓글 ❌ ✅ (Guest) Markdown ✅ ⚠️ 데이터 소유 ✅ ❌ 추천 개발자 블로그 일반 블로그 마이그레이션 가이드 # Utterances → Giscus # 1. GitHub Issues를 Discussions로 변환 - 수동 작업 필요 (자동화 없음) - 또는 Issues 그대로 두고 Giscus 새로 시작 2. comments.html 파일 교체 - Utterances 코드 삭제 - Giscus 코드 추가 3. 배포 Disqus → Giscus # 1. Disqus 데이터 Export (XML) 2. GitHub Discussions로 수동 이전 - 자동화 도구 없음 - 스크립트 직접 작성 필요 - 또는 새로 시작 권장 추가 리소스 # 공식 문서 # Giscus 공식 사이트 Giscus GitHub 커뮤니티 # Giscus Discussions Blowfish 문서 체크리스트 # 설치 완료 확인:\nGitHub Discussions 활성화 Giscus App 설치 layouts/partials/comments.html 생성 Giscus 코드 삽입 (본인의 ID로) params.toml에 showComments = true 로컬 테스트 완료 GitHub에 푸시 배포된 사이트에서 확인 테스트 댓글 작성 GitHub Discussions에 생성 확인 결론 # Giscus는 Hugo/GitHub Pages 블로그에 가장 적합한 댓글 시스템입니다:\n장점 정리 # ✅ 완전 무료 ✅ 설정 간단 (10분) ✅ 서버 불필요 ✅ Markdown 완벽 지원 ✅ GitHub 통합 ✅ 데이터 소유\n단점 # ❌ GitHub 계정 필수 (익명 불가) ❌ 기술 블로그에 적합 (일반 사용자는 허들 있음)\n추천 대상 # ✅ 개발자 블로그 ✅ 기술 문서 ✅ 오픈소스 프로젝트 ","date":"2025-10-17","externalUrl":null,"permalink":"/posts/251017_comments_giscus/","section":"Posts","summary":"무료로 Markdown 지원하는 댓글 시스템을 10분 만에 추가하는 방법","title":"Giscus로 Hugo 블로그에 댓글 기능 추가하기","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"GitHub","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"GitHub Pages","type":"tags"},{"content":" 개요 # 정적 사이트 생성기(Hugo)로 만든 블로그에 댓글 기능을 추가하는 모든 방법을 비교 분석합니다. 익명 댓글, GitHub 로그인, 소셜 로그인 등 다양한 요구사항에 맞는 솔루션을 제시합니다.\n댓글 시스템 분류 # 인증 방식에 따른 분류 # 인증 방식 시스템 GitHub 전용 Giscus, Utterances 익명 가능 Remark42, Commento, Comentario, HashOver 익명 + 소셜 로그인 Remark42, Commento, Disqus 소셜 로그인만 Disqus, Hyvor Talk 호스팅 방식에 따른 분류 # 호스팅 시스템 SaaS (관리 불필요) Giscus, Utterances, Disqus, Hyvor Talk 셀프 호스팅 Remark42, Commento, Comentario, HashOver 하이브리드 Cusdis (Vercel 무료 배포) 1. Giscus (최고 추천 - GitHub 사용자용) # 개념 # GitHub Discussions를 백엔드로 사용하는 댓글 시스템\n동작 방식 # 1. 사용자가 블로그 방문 ↓ 2. Giscus 위젯 로드 ↓ 3. GitHub OAuth로 로그인 ↓ 4. 댓글 작성 ↓ 5. GitHub Discussions에 자동 저장 ↓ 6. 블로그에 실시간 표시 장점 # ✅ 완전 무료 (GitHub 기능 활용) ✅ 서버 불필요 (GitHub이 백엔드) ✅ 데이터 소유 (본인 저장소에 저장) ✅ Markdown 지원 (코드 블록, 이미지 등) ✅ 반응(Reactions) 지원 (👍, ❤️ 등) ✅ 알림 (GitHub 알림으로 댓글 알림) ✅ 다크 모드 (블로그 테마와 동기화) ✅ 스팸 방지 (GitHub 계정 필요) ✅ 관리 간편 (GitHub Discussions에서 관리) ✅ 검색 가능 (GitHub 검색으로 댓글 검색) 단점 # ❌ 익명 댓글 불가 (GitHub 계정 필수) ❌ 기술 블로그에 적합 (일반 사용자는 GitHub 계정 없을 수 있음) ❌ GitHub 의존성 (GitHub 장애 시 댓글 불가) 구현 난이도 # ⭐⭐ (2/5)\n설정 방법 # 1단계: GitHub Discussions 활성화 # 1. GitHub 저장소 → Settings 2. Features 섹션 → Discussions 체크 2단계: Giscus 설정 # giscus.app 방문 저장소 입력: username/repository 설정 선택: 페이지 ↔️ Discussion 연결: pathname (권장) Discussion 카테고리: Announcements 또는 General 기능: 반응, 댓글 위로 테마: 블로그에 맞게 선택 3단계: Blowfish에 추가 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;YOUR_REPO_ID\u0026#34; data-category=\u0026#34;Announcements\u0026#34; data-category-id=\u0026#34;YOUR_CATEGORY_ID\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 4단계: params.toml 설정 # [article] showComments = true 테마 동기화 (다크모드) # \u0026lt;script\u0026gt; // 블로그 테마 변경 시 Giscus 테마도 변경 const giscusTheme = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); if (giscusTheme) { const theme = document.documentElement.getAttribute(\u0026#39;data-theme\u0026#39;); giscusTheme.contentWindow.postMessage({ giscus: { setConfig: { theme: theme === \u0026#39;dark\u0026#39; ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39; } } }, \u0026#39;https://giscus.app\u0026#39;); } \u0026lt;/script\u0026gt; 비용 # 완전 무료\n추천 대상 # ✅ 개발자 블로그 ✅ 기술 문서 ✅ 오픈소스 프로젝트 블로그 2. Utterances # 개념 # GitHub Issues를 백엔드로 사용하는 댓글 시스템 (Giscus의 전신)\n동작 방식 # 1. GitHub OAuth 로그인 ↓ 2. 댓글 작성 ↓ 3. GitHub Issues에 저장 (각 포스트 = 1개 Issue) ↓ 4. 블로그에 표시 장점 # ✅ 완전 무료 ✅ 가벼움 (TypeScript) ✅ 간단한 설정 ✅ Markdown 지원 단점 # ❌ Issues 사용 (Discussions보다 덜 적합) ❌ Giscus보다 기능 적음 ❌ 익명 불가 Giscus vs Utterances # 기능 Giscus Utterances 백엔드 Discussions Issues 반응 ✅ ❌ 댓글에 댓글 ✅ (nested) ⚠️ (flat) 적합성 댓글 전용 이슈 트래킹용 결론: Giscus가 Utterances의 상위 호환\n구현 난이도 # ⭐⭐ (2/5)\n설정 방법 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;username/repository\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 추천 대상 # 특별한 이유가 없다면 Giscus 사용 권장 3. Remark42 (최고 추천 - 익명 + 소셜 로그인) # 개념 # 오픈소스 셀프 호스팅 댓글 시스템으로, 익명 및 다양한 소셜 로그인 지원\n동작 방식 # 1. Remark42 서버 배포 (Docker) ↓ 2. 블로그에 Remark42 스크립트 삽입 ↓ 3. 사용자 선택: - 익명 댓글 작성 - GitHub/Google/Twitter 로그인 후 작성 ↓ 4. Remark42 DB에 저장 ↓ 5. 블로그에 표시 장점 # ✅ 익명 댓글 가능 (설정으로 켜고 끌 수 있음) ✅ 다양한 소셜 로그인 (GitHub, Google, Facebook, Twitter, Email) ✅ 완전 무료 (오픈소스) ✅ 광고 없음 ✅ 데이터 소유 (본인 서버) ✅ Markdown 지원 ✅ 댓글 수정/삭제 ✅ 관리자 모드 (댓글 승인/차단/삭제) ✅ 알림 (이메일/Telegram) ✅ Import/Export (다른 시스템에서 마이그레이션) ✅ 투표 (찬성/반대) ✅ 스팸 필터 단점 # ❌ 셀프 호스팅 필요 (Docker 서버) ❌ 유지보수 책임 ❌ 호스팅 비용 (월 $5~, 무료 티어 가능) 구현 난이도 # ⭐⭐⭐⭐ (4/5)\n호스팅 옵션 # 옵션 1: Railway (추천) # 1. Railway.app 회원가입 2. \u0026#34;New Project\u0026#34; → \u0026#34;Deploy from GitHub\u0026#34; 3. Remark42 Docker 이미지 선택 4. 환경변수 설정: - REMARK_URL=https://your-remark42.railway.app - SECRET=your-random-secret - AUTH_ANON=true # 익명 댓글 허용 - AUTH_GITHUB_CID=your_client_id - AUTH_GITHUB_CSEC=your_client_secret Railway 무료 티어:\n월 $5 크레딧 소규모 블로그 충분 옵션 2: Fly.io # # fly.toml app = \u0026#34;my-remark42\u0026#34; [build] image = \u0026#34;umputun/remark42:latest\u0026#34; [env] REMARK_URL = \u0026#34;https://my-remark42.fly.dev\u0026#34; AUTH_ANON = \u0026#34;true\u0026#34; AUTH_GITHUB_CID = \u0026#34;xxx\u0026#34; AUTH_GITHUB_CSEC = \u0026#34;xxx\u0026#34; fly launch fly deploy Fly.io 무료 티어:\n3개 앱 소규모 블로그 충분 옵션 3: Docker Compose (VPS) # # docker-compose.yml version: \u0026#39;3.8\u0026#39; services: remark42: image: umputun/remark42:latest restart: always environment: - REMARK_URL=https://remark.your-blog.com - SECRET=your-secret-key-change-this - AUTH_ANON=true # 익명 허용 - AUTH_GITHUB_CID=xxx # GitHub 로그인 - AUTH_GITHUB_CSEC=xxx - AUTH_GOOGLE_CID=xxx # Google 로그인 - AUTH_GOOGLE_CSEC=xxx - ADMIN_SHARED_ID=github_username # 관리자 volumes: - ./data:/srv/var ports: - \u0026#34;8080:8080\u0026#34; docker-compose up -d 블로그 삽입 코드 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;div id=\u0026#34;remark42\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var remark_config = { host: \u0026#39;https://your-remark42.railway.app\u0026#39;, site_id: \u0026#39;0andwild-blog\u0026#39;, components: [\u0026#39;embed\u0026#39;], theme: \u0026#39;light\u0026#39;, locale: \u0026#39;ko\u0026#39;, max_shown_comments: 10, simple_view: false, no_footer: false }; (function(c) { for(var i = 0; i \u0026lt; c.length; i++){ var d = document, s = d.createElement(\u0026#39;script\u0026#39;); s.src = remark_config.host + \u0026#39;/web/\u0026#39; +c[i] +\u0026#39;.js\u0026#39;; s.defer = true; (d.head || d.body).appendChild(s); } })(remark_config.components || [\u0026#39;embed\u0026#39;]); \u0026lt;/script\u0026gt; 익명 + GitHub 동시 사용 설정 # # 환경변수 AUTH_ANON=true # 익명 허용 AUTH_GITHUB_CID=xxx # GitHub OAuth App ID AUTH_GITHUB_CSEC=xxx # GitHub OAuth App Secret ANON_VOTE=false # 익명 사용자 투표 불가 (스팸 방지) 사용자는 선택 가능:\n\u0026ldquo;익명으로 댓글 달기\u0026rdquo; \u0026ldquo;GitHub으로 로그인\u0026rdquo; 관리자 기능 # # 관리자 지정 ADMIN_SHARED_ID=github_yourusername # 또는 이메일 ADMIN_SHARED_EMAIL=you@example.com 관리자 가능 작업:\n댓글 삭제 사용자 차단 댓글 고정 읽기 전용 모드 비용 # Railway: 무료 또는 월 $5 Fly.io: 무료 티어 가능 VPS (DigitalOcean 등): 월 $5~ 추천 대상 # ✅ 익명 + 소셜 로그인 모두 원하는 경우 ✅ 기술적으로 Docker 다룰 수 있는 사용자 ✅ 데이터 완전 통제 원하는 경우 4. Commento / Comentario # 개념 # 프라이버시 중심의 경량 댓글 시스템\nCommento vs Comentario # 항목 Commento Comentario 상태 개발 중단 활발히 개발 중 (Commento 포크) 라이선스 MIT MIT 언어 Go Go 추천 ❌ ✅ 결론: Comentario 사용 권장\nComentario 장점 # ✅ 익명 댓글 가능 ✅ 소셜 로그인 (GitHub, Google, GitLab, SSO) ✅ 가벼움 (Go 기반) ✅ 프라이버시 중심 ✅ Markdown 지원 ✅ 투표 기능 단점 # ❌ 셀프 호스팅 필요 ❌ Remark42보다 기능 적음 구현 난이도 # ⭐⭐⭐⭐ (4/5)\nDocker 배포 # version: \u0026#39;3.8\u0026#39; services: comentario: image: registry.gitlab.com/comentario/comentario ports: - \u0026#34;8080:8080\u0026#34; environment: - COMENTARIO_ORIGIN=https://comments.your-blog.com - COMENTARIO_BIND=0.0.0.0:8080 - COMENTARIO_POSTGRES=postgres://user:pass@db/comentario depends_on: - db db: image: postgres:15 environment: - POSTGRES_DB=comentario - POSTGRES_USER=comentario - POSTGRES_PASSWORD=change-this volumes: - postgres_data:/var/lib/postgresql/data volumes: postgres_data: 블로그 삽입 # \u0026lt;script defer src=\u0026#34;https://comments.your-blog.com/js/commento.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;commento\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 추천 대상 # Remark42 대안 더 간단한 시스템 원하는 경우 5. Disqus (전통적 SaaS) # 개념 # 가장 오래되고 널리 사용되는 클라우드 댓글 시스템\n동작 방식 # 1. Disqus 계정 생성 및 사이트 등록 ↓ 2. 블로그에 Disqus 스크립트 삽입 ↓ 3. 사용자 선택: - Guest (익명 - 이메일 필요) - Disqus 계정 - Facebook/Twitter/Google 로그인 ↓ 4. Disqus 서버에 저장 ↓ 5. 블로그에 표시 장점 # ✅ 설정 초간단 (5분) ✅ 서버 불필요 (SaaS) ✅ Guest 모드 (이메일만으로 댓글) ✅ 소셜 로그인 (Facebook, Twitter, Google) ✅ 강력한 관리자 도구 ✅ 스팸 필터 (Akismet 통합) ✅ 모바일 앱 (iOS/Android) ✅ 분석/통계 단점 # ❌ 광고 표시 (무료 플랜) ❌ 무거움 (스크립트 크기) ❌ 프라이버시 우려 (데이터 추적) ❌ 데이터 소유권 없음 (Disqus 서버) ❌ GitHub 로그인 없음 ❌ 광고 제거 비용 (월 $11.99~) 구현 난이도 # ⭐ (1/5) - 가장 쉬움\n설정 방법 # 1단계: Disqus 사이트 등록 # 1. disqus.com 가입 2. \u0026#34;I want to install Disqus on my site\u0026#34; 선택 3. Website Name 입력 (예: andwild-blog) 4. Category 선택 5. Plan 선택 (Basic - Free) 2단계: Blowfish 설정 # # config/_default/config.toml [services.disqus] shortname = \u0026#34;andwild-blog\u0026#34; # 1단계에서 생성한 이름 # config/_default/params.toml [article] showComments = true Hugo는 Disqus를 기본 지원하므로 자동으로 댓글 표시됨!\n3단계: Guest 댓글 허용 # Disqus Dashboard → Settings → Community → Guest Commenting: Allow guests to comment (체크) 광고 제거 방법 # 방법 1: 유료 플랜 ($11.99/월~) # Plus Plan: 광고 없음 Pro Plan: 광고 없음 + 고급 기능 방법 2: CSS로 숨기기 (비추천 - 약관 위반 가능) # /* 비추천: Disqus 약관 위반 가능 */ #disqus_thread iframe[src*=\u0026#34;ads\u0026#34;] { display: none !important; } 비용 # 무료: 광고 있음 Plus: $11.99/월 (광고 없음) Pro: $89/월 (고급 기능) 추천 대상 # ✅ 빠르게 댓글 추가하고 싶은 경우 ✅ 비기술적 블로거 ✅ 광고 신경 안 쓰는 경우 ❌ 프라이버시 중시하는 경우는 비추천 6. Cusdis (Vercel 무료 배포) # 개념 # 경량 오픈소스 댓글 시스템, Vercel에 무료 배포 가능\n동작 방식 # 1. Cusdis를 Vercel에 배포 (1-Click) ↓ 2. PostgreSQL 연결 (Vercel 무료) ↓ 3. 대시보드에서 사이트 추가 ↓ 4. 블로그에 스크립트 삽입 ↓ 5. 사용자가 이메일 + 이름으로 댓글 장점 # ✅ 완전 무료 (Vercel 무료 티어) ✅ 익명 댓글 (이메일 + 이름만) ✅ 가벼움 (50KB) ✅ 설정 간단 (Vercel 1-Click 배포) ✅ 프라이버시 중심 ✅ 오픈소스 단점 # ❌ Markdown 미지원 ❌ 소셜 로그인 없음 ❌ 기능 단순 구현 난이도 # ⭐⭐⭐ (3/5)\n설정 방법 # 1단계: Vercel 배포 # 1. https://cusdis.com/ 방문 2. \u0026#34;Deploy with Vercel\u0026#34; 클릭 3. GitHub 연결 4. PostgreSQL 추가 (Vercel Storage) 5. 배포 완료 2단계: 사이트 추가 # 1. 배포된 Cusdis 대시보드 접속 2. \u0026#34;Add Website\u0026#34; 클릭 3. Domain 입력: 0andwild.github.io 4. App ID 복사 3단계: 블로그 삽입 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;div id=\u0026#34;cusdis_thread\u0026#34; data-host=\u0026#34;https://your-cusdis.vercel.app\u0026#34; data-app-id=\u0026#34;YOUR_APP_ID\u0026#34; data-page-id=\u0026#34;{{ .File.UniqueID }}\u0026#34; data-page-url=\u0026#34;{{ .Permalink }}\u0026#34; data-page-title=\u0026#34;{{ .Title }}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script async defer src=\u0026#34;https://your-cusdis.vercel.app/js/cusdis.es.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 비용 # 완전 무료 (Vercel 무료 티어)\n추천 대상 # ✅ 간단한 익명 댓글만 필요한 경우 ✅ 완전 무료 원하는 경우 ✅ Vercel 사용 경험 있는 경우 7. HashOver # 개념 # PHP 기반의 완전 익명 댓글 시스템\n장점 # ✅ 완전 익명 (아무 정보도 필요 없음) ✅ PHP + flat file (DB 불필요) ✅ 오픈소스 단점 # ❌ PHP 필요 (정적 사이트에 부적합) ❌ GitHub 로그인 없음 ❌ 오래된 프로젝트 구현 난이도 # ⭐⭐⭐⭐ (4/5)\n추천 대상 # ❌ 정적 블로그에는 비추천 PHP 서버 있을 때만 고려 8. Hyvor Talk (프리미엄 SaaS) # 개념 # 광고 없는 프리미엄 댓글 시스템\n장점 # ✅ 광고 없음 ✅ 익명 댓글 가능 ✅ 소셜 로그인 ✅ 강력한 스팸 필터 단점 # ❌ 유료 (월 $5~) ❌ GitHub 로그인 없음 비용 # Starter: $5/월 (1 사이트) Pro: $15/월 (3 사이트) 추천 대상 # Disqus 유료 대안 광고 없는 SaaS 원하는 경우 비교표 # 인증 방식별 # 시스템 익명 GitHub Google 기타 소셜 난이도 비용 Giscus ❌ ✅ ❌ ❌ ⭐⭐ 무료 Utterances ❌ ✅ ❌ ❌ ⭐⭐ 무료 Remark42 ✅ ✅ ✅ ✅ ⭐⭐⭐⭐ $5/월 Comentario ✅ ✅ ✅ ✅ ⭐⭐⭐⭐ $5/월 Disqus ⚠️ ❌ ✅ ✅ ⭐ 무료 (광고) Cusdis ✅ ❌ ❌ ❌ ⭐⭐⭐ 무료 Hyvor Talk ✅ ❌ ✅ ✅ ⭐ $5/월 기능별 # 시스템 Markdown 반응 투표 알림 관리자 스팸필터 Giscus ✅ ✅ ❌ ✅ ⚠️ ✅ Remark42 ✅ ❌ ✅ ✅ ✅ ✅ Disqus ⚠️ ❌ ✅ ✅ ✅ ✅ Cusdis ❌ ❌ ❌ ⚠️ ✅ ⚠️ 호스팅별 # 시스템 호스팅 데이터 위치 의존성 Giscus GitHub GitHub Discussions GitHub Remark42 셀프 본인 서버 Docker Disqus Disqus Disqus 서버 Disqus Cusdis Vercel Vercel DB Vercel 선택 가이드 # 시나리오별 추천 # 1. \u0026ldquo;개발자 블로그, GitHub 사용자 대상\u0026rdquo; # → Giscus ⭐⭐⭐⭐⭐\n무료, 간단, Markdown 지원 GitHub 통합으로 알림도 편함 2. \u0026ldquo;일반 블로그, 익명 댓글 필수\u0026rdquo; # → Cusdis (간단) 또는 Remark42 (고급)\nCusdis: 5분 설정, 완전 무료 Remark42: 더 많은 기능, 소셜 로그인 포함 3. \u0026ldquo;익명 + GitHub 로그인 둘 다\u0026rdquo; # → Remark42 ⭐⭐⭐⭐⭐\n유일하게 둘 다 지원 관리자 기능 강력 4. \u0026ldquo;기술 없음, 빠르게 설정\u0026rdquo; # → Disqus\n5분 설정 광고는 감수 5. \u0026ldquo;완전 무료 + 서버 관리 싫음\u0026rdquo; # → Giscus (GitHub) 또는 Cusdis (익명)\n6. \u0026ldquo;프라이버시 최우선\u0026rdquo; # → Remark42 또는 Comentario (셀프 호스팅)\n데이터 완전 통제 실전 구현: Blowfish + Giscus # 전체 설정 과정 # 1. GitHub Discussions 활성화 # GitHub 저장소 → Settings → Features → Discussions 체크 2. Giscus App 설치 # https://github.com/apps/giscus 방문 → Install → 저장소 선택 3. Giscus 설정 생성 # giscus.app/ko에서:\n저장소: 0AndWild/0AndWild.github.io 매핑: pathname 카테고리: Announcements 테마: preferred_color_scheme 언어: ko 생성된 코드 복사\n4. 파일 생성 # # 디렉토리 생성 (없으면) mkdir -p layouts/partials # 파일 생성 touch layouts/partials/comments.html 5. 코드 삽입 # \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;0AndWild/0AndWild.github.io\u0026#34; data-repo-id=\u0026#34;R_xxxxxxxxxxxxx\u0026#34; data-category=\u0026#34;Announcements\u0026#34; data-category-id=\u0026#34;DIC_xxxxxxxxxxxxx\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;ko\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 6. params.toml 수정 # [article] showComments = true 7. 로컬 테스트 # hugo server -D # http://localhost:1313 에서 확인 8. 배포 # git add . git commit -m \u0026#34;Add Giscus comments\u0026#34; git push 실전 구현: Blowfish + Remark42 (Railway) # 전체 설정 과정 # 1. GitHub OAuth App 생성 # GitHub → Settings → Developer settings → OAuth Apps → New OAuth App Application name: AndWild Blog Comments Homepage URL: https://0andwild.github.io Authorization callback URL: https://your-remark42.railway.app/auth/github/callback 생성 후: Client ID 복사 Client Secret 생성 및 복사 2. Railway 배포 # 1. railway.app 가입 2. \u0026#34;New Project\u0026#34; → \u0026#34;Deploy Docker Image\u0026#34; 3. Image: umputun/remark42:latest 4. 환경변수 추가: REMARK_URL=https://your-project.railway.app SECRET=randomly-generated-secret-key-change-this SITE=0andwild-blog AUTH_ANON=true AUTH_GITHUB_CID=your_github_client_id AUTH_GITHUB_CSEC=your_github_client_secret ADMIN_SHARED_ID=github_yourusername 3. 배포 확인 # Railway가 자동으로 URL 생성: https://your-project.railway.app 브라우저에서 접속하여 Remark42 UI 확인 4. Blowfish 설정 # mkdir -p layouts/partials touch layouts/partials/comments.html \u0026lt;!-- layouts/partials/comments.html --\u0026gt; \u0026lt;div id=\u0026#34;remark42\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var remark_config = { host: \u0026#39;https://your-project.railway.app\u0026#39;, site_id: \u0026#39;0andwild-blog\u0026#39;, components: [\u0026#39;embed\u0026#39;], theme: \u0026#39;light\u0026#39;, locale: \u0026#39;ko\u0026#39; }; (function(c) { for(var i = 0; i \u0026lt; c.length; i++){ var d = document, s = d.createElement(\u0026#39;script\u0026#39;); s.src = remark_config.host + \u0026#39;/web/\u0026#39; +c[i] +\u0026#39;.js\u0026#39;; s.defer = true; (d.head || d.body).appendChild(s); } })(remark_config.components || [\u0026#39;embed\u0026#39;]); \u0026lt;/script\u0026gt; 5. params.toml # [article] showComments = true 6. 테스트 및 배포 # hugo server -D # 확인 후 git add . git commit -m \u0026#34;Add Remark42 comments\u0026#34; git push 마이그레이션 가이드 # Disqus → Giscus # 1. Disqus에서 데이터 Export (XML) 2. GitHub Discussions로 수동 이전 (자동화 스크립트 없음, 수동 작업 필요) Disqus → Remark42 # 1. Disqus XML Export 2. Remark42 Admin → Import → Disqus 선택 3. XML 파일 업로드 결론 # 최종 추천 # 상황 추천 시스템 이유 개발자 블로그 Giscus 무료, GitHub 통합, Markdown 일반 블로그 (익명 필요) Cusdis 무료, 간단, 익명 익명 + 소셜 둘 다 Remark42 유연함, 모든 기능 빠른 설정 Disqus 5분 완료 (광고 감수) 완전 통제 Remark42 셀프 호스팅, 커스터마이징 개인 추천 (0AndWild 블로그) # Giscus 사용 권장\nGitHub Pages 블로그에 완벽히 어울림 기술 블로그는 GitHub 사용자가 주 독자 무료, 간단, 유지보수 없음 대안: Remark42 (익명 댓글 원할 때)\n빠른시작 # Giscus로 시작 (10분) 사용자 피드백 수집 익명 댓글 요청 많으면 Remark42로 전환 고려 댓글 시스템은 나중에도 바꿀 수 있으니, 일단 Giscus로 시작하는 것을 강력히 권장합니다!\n","date":"2025-10-17","externalUrl":null,"permalink":"/posts/251017_comments_guide/","section":"Posts","summary":"Giscus, Utterances, Remark42, Disqus 등 모든 댓글 시스템의 장단점과 구현 방법","title":"Hugo \u0026 GithubPages 블로그 댓글 시스템 구현 가이드","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/static-site/","section":"Tags","summary":"","title":"Static Site","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/automation/","section":"Tags","summary":"","title":"Automation","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/email/","section":"Tags","summary":"","title":"Email","type":"tags"},{"content":" 개요 # 정적 사이트 생성기(Hugo)로 만든 블로그에 구독 및 이메일 알림 기능을 추가하는 방법을 분석합니다. 특히 키워드 기반 선택적 알림 기능 구현까지 다룹니다.\n1. RSS Feed + 이메일 서비스 # 개념 # Hugo의 기본 RSS Feed를 이메일로 변환하는 서비스를 활용하는 방식입니다.\n방법 A: Blogtrottr # 동작 방식 # 1. Hugo가 자동 생성한 RSS Feed (index.xml) ↓ 2. 사용자가 Blogtrottr에 RSS URL 등록 ↓ 3. Blogtrottr가 주기적으로 RSS 확인 ↓ 4. 새 글 감지 시 이메일 발송 장점 # ✅ 개발자 작업 없음 (링크만 제공) ✅ 완전 무료 ✅ 즉시 사용 가능 ✅ 서버 없이 동작 단점 # ❌ 구독자 관리 불가 ❌ 이메일 디자인 커스텀 불가 ❌ 통계 없음 ❌ 키워드 필터링 불가 ❌ 사용자가 직접 외부 사이트에서 등록해야 함 구현 난이도 # ⭐ (1/5) - 가장 쉬움\n사용 예시 # 블로그에 링크 추가: [이메일로 구독하기](https://blogtrottr.com) (사이트에서 https://0andwild.github.io/index.xml 입력) 방법 B: FeedBurner (Google) # 동작 방식 # 1. FeedBurner에 RSS Feed 등록 ↓ 2. FeedBurner가 RSS를 프록시/관리 ↓ 3. 구독 폼을 블로그에 삽입 ↓ 4. 사용자가 블로그에서 직접 구독 ↓ 5. 새 글 발행 시 자동 이메일 발송 장점 # ✅ 기본 통계 제공 ✅ 구독 폼 제공 ✅ 무료 ✅ RSS 관리 기능 단점 # ❌ Google의 지원 중단 가능성 (업데이트 중단됨) ❌ 키워드 필터링 불가 ❌ 커스텀 제한적 ❌ 오래된 UI 구현 난이도 # ⭐⭐ (2/5)\n2. Mailchimp + RSS Campaign (추천) # 개념 # 전문 이메일 마케팅 플랫폼을 활용하여 RSS Feed를 자동으로 이메일로 변환\n동작 방식 # 1. Mailchimp에 RSS Campaign 생성 ↓ 2. RSS URL 등록 및 체크 주기 설정 (일/주/월) ↓ 3. 블로그에 Mailchimp 구독 폼 삽입 ↓ 4. 사용자가 이메일 입력하여 구독 ↓ 5. 새 글 감지 시 자동으로 이메일 템플릿 생성 ↓ 6. 전체 구독자에게 발송 장점 # ✅ 무료 티어: 2,000명 구독자까지 ✅ 전문적인 이메일 디자인 (드래그 앤 드롭 에디터) ✅ 구독자 관리 (추가/삭제/세그먼트) ✅ 상세한 통계 (오픈율, 클릭율, 구독 해지율) ✅ 구독 폼 자동 생성 (임베드 코드 제공) ✅ 자동화 (새 글만 발송) ✅ 모바일 최적화 ✅ 스팸 필터 회피 (전문 발송 서버) 단점 # ❌ 키워드 필터링 기본 미지원 (Pro 플랜에서 태그별 세그먼트 가능) ❌ 무료 티어에서 Mailchimp 로고 표시 ❌ 2,000명 초과 시 유료 ($13/월~) 구현 난이도 # ⭐⭐ (2/5)\n설정 단계 # 1. Mailchimp 계정 생성 2. Audience 생성 3. Campaign → Create → Email → RSS Campaign 4. RSS URL 입력: https://your-blog.com/index.xml 5. 발송 주기 설정 (Daily/Weekly) 6. 이메일 템플릿 디자인 7. 구독 폼 코드 복사 8. Hugo에 삽입 (layouts/partials/subscribe.html) 블로그 삽입 코드 예시 # \u0026lt;!-- Mailchimp 구독 폼 --\u0026gt; \u0026lt;div id=\u0026#34;mc_embed_signup\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;https://your-mailchimp-url.com/subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;EMAIL\u0026#34; placeholder=\u0026#34;이메일 주소\u0026#34; required\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;구독하기\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 3. Buttondown (개발자 친화적, 추천) # 개념 # Markdown 기반의 뉴스레터 플랫폼으로, API를 통한 커스터마이징이 가능\n동작 방식 # 1. Buttondown에 RSS Feed 연동 ↓ 2. 자동으로 RSS 항목을 Markdown 이메일로 변환 ↓ 3. 구독자가 태그/키워드 선택 가능 ↓ 4. API를 통해 특정 태그 구독자만 필터링 가능 ↓ 5. 매칭되는 구독자에게만 발송 장점 # ✅ 무료 티어: 1,000명까지 ✅ Markdown 기반 (개발자 친화적) ✅ 강력한 API (커스텀 가능) ✅ 태그 기반 구독 (키워드 필터링 구현 가능) ✅ 광고 없음 ✅ 깔끔한 UI ✅ RSS import 자동화 ✅ 프라이버시 중심 단점 # ❌ 이메일 디자인이 단순 (Markdown만) ❌ 통계 기능이 Mailchimp보다 약함 ❌ 한국어 지원 부족 구현 난이도 # ⭐⭐⭐ (3/5) - API 사용 시 난이도 증가\n키워드 알림 구현 예시 # 1단계: 구독 폼에 태그 선택 추가 # \u0026lt;form action=\u0026#34;https://buttondown.email/api/emails/embed-subscribe/YOUR_ID\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34; placeholder=\u0026#34;이메일\u0026#34; required\u0026gt; \u0026lt;label\u0026gt;관심 주제 선택:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;tags\u0026#34; value=\u0026#34;kubernetes\u0026#34;\u0026gt; Kubernetes \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;tags\u0026#34; value=\u0026#34;docker\u0026#34;\u0026gt; Docker \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;tags\u0026#34; value=\u0026#34;golang\u0026#34;\u0026gt; Go \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;구독하기\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 2단계: GitHub Actions로 선택적 발송 # name: Send Newsletter on: push: paths: - \u0026#39;content/posts/**\u0026#39; jobs: send: runs-on: ubuntu-latest steps: - name: Extract tags from post run: | TAGS=$(grep \u0026#34;^tags = \u0026#34; content/posts/*/index.md | cut -d\u0026#39;\u0026#34;\u0026#39; -f2) echo \u0026#34;POST_TAGS=$TAGS\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV - name: Send to matching subscribers run: | curl -X POST https://api.buttondown.email/v1/emails \\ -H \u0026#34;Authorization: Token ${{ secrets.BUTTONDOWN_API_KEY }}\u0026#34; \\ -d \u0026#34;subject=New Post\u0026#34; \\ -d \u0026#34;body=...\u0026#34; \\ -d \u0026#34;tag=$POST_TAGS\u0026#34; 4. SendGrid + GitHub Actions (완전 커스텀) # 개념 # 이메일 발송 API와 CI/CD를 결합하여 완전히 커스터마이징된 알림 시스템 구축\n동작 방식 # 1. 새 글 작성 후 Git Push ↓ 2. GitHub Actions 트리거 ↓ 3. Action에서 Front Matter 파싱 - 글 제목, 요약, 태그 추출 ↓ 4. 구독자 DB 조회 (Supabase/JSON 파일) - 각 구독자의 관심 키워드와 매칭 ↓ 5. 매칭되는 구독자만 필터링 ↓ 6. SendGrid API로 개별 이메일 발송 장점 # ✅ 완전한 통제 (모든 로직 커스터마이징) ✅ 키워드 알림 완벽 구현 ✅ 무료 티어: SendGrid 월 100통 ✅ 자동화 (Git push만 하면 됨) ✅ 확장 가능 (DB, 로직 자유롭게) ✅ 구독자 데이터 소유 단점 # ❌ 개발 작업 필요 ❌ 유지보수 부담 ❌ SendGrid 무료 티어 제한적 (월 100통) ❌ 구독 폼, DB 직접 구현 필요 ❌ 스팸 필터 회피 설정 필요 구현 난이도 # ⭐⭐⭐⭐⭐ (5/5) - 가장 복잡\n아키텍처 # 구독자 데이터베이스 옵션 # 옵션 A: JSON 파일 (간단)\n// subscribers.json (GitHub 저장소에 암호화하여 저장) [ { \u0026#34;email\u0026#34;: \u0026#34;user@example.com\u0026#34;, \u0026#34;keywords\u0026#34;: [\u0026#34;kubernetes\u0026#34;, \u0026#34;docker\u0026#34;], \u0026#34;active\u0026#34;: true }, { \u0026#34;email\u0026#34;: \u0026#34;dev@example.com\u0026#34;, \u0026#34;keywords\u0026#34;: [\u0026#34;golang\u0026#34;, \u0026#34;rust\u0026#34;], \u0026#34;active\u0026#34;: true } ] 옵션 B: Supabase (권장)\n-- subscribers 테이블 CREATE TABLE subscribers ( id UUID PRIMARY KEY, email TEXT UNIQUE NOT NULL, keywords TEXT[], -- 배열 형태 active BOOLEAN DEFAULT true, created_at TIMESTAMP DEFAULT NOW() ); GitHub Actions 워크플로우 # name: Email Notification on: push: branches: [main] paths: - \u0026#39;content/posts/**\u0026#39; jobs: notify: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Setup Node.js uses: actions/setup-node@v3 with: node-version: \u0026#39;18\u0026#39; - name: Extract Post Metadata id: metadata run: | # 가장 최근 수정된 포스트 찾기 POST_FILE=$(git diff-tree --no-commit-id --name-only -r ${{ github.sha }} | grep \u0026#39;content/posts\u0026#39; | head -1) # Front Matter 파싱 TITLE=$(grep \u0026#34;^title = \u0026#34; $POST_FILE | cut -d\u0026#39;\u0026#34;\u0026#39; -f2) TAGS=$(grep \u0026#34;^tags = \u0026#34; $POST_FILE | sed \u0026#39;s/tags = \\[//;s/\\]//;s/\u0026#34;//g\u0026#39;) SUMMARY=$(grep \u0026#34;^summary = \u0026#34; $POST_FILE | cut -d\u0026#39;\u0026#34;\u0026#39; -f2) URL=\u0026#34;https://0andwild.github.io/$(dirname $POST_FILE | sed \u0026#39;s/content\\///\u0026#39;)\u0026#34; echo \u0026#34;title=$TITLE\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#34;tags=$TAGS\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#34;summary=$SUMMARY\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#34;url=$URL\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT - name: Query Matching Subscribers id: subscribers run: | # Supabase에서 매칭되는 구독자 조회 curl -X POST https://YOUR_PROJECT.supabase.co/rest/v1/rpc/get_matching_subscribers \\ -H \u0026#34;apikey: ${{ secrets.SUPABASE_KEY }}\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#34;{\\\u0026#34;post_tags\\\u0026#34;: \\\u0026#34;${{ steps.metadata.outputs.tags }}\\\u0026#34;}\u0026#34; \\ \u0026gt; subscribers.json - name: Send Emails via SendGrid run: | # Node.js 스크립트 실행 cat \u0026gt; send-emails.js \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; const sgMail = require(\u0026#39;@sendgrid/mail\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); sgMail.setApiKey(process.env.SENDGRID_API_KEY); const subscribers = JSON.parse(fs.readFileSync(\u0026#39;subscribers.json\u0026#39;)); const title = process.env.POST_TITLE; const summary = process.env.POST_SUMMARY; const url = process.env.POST_URL; subscribers.forEach(async (subscriber) =\u0026gt; { const msg = { to: subscriber.email, from: \u0026#39;noreply@0andwild.github.io\u0026#39;, subject: `새 글: ${title}`, html: ` \u0026lt;h2\u0026gt;${title}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;${summary}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;관심 키워드와 일치: ${subscriber.matched_keywords.join(\u0026#39;, \u0026#39;)}\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;${url}\u0026#34;\u0026gt;글 읽기\u0026lt;/a\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;small\u0026gt;\u0026lt;a href=\u0026#34;https://0andwild.github.io/unsubscribe?token=${subscriber.token}\u0026#34;\u0026gt;구독 취소\u0026lt;/a\u0026gt;\u0026lt;/small\u0026gt; ` }; await sgMail.send(msg); console.log(`Email sent to ${subscriber.email}`); }); EOF npm install @sendgrid/mail node send-emails.js env: SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }} POST_TITLE: ${{ steps.metadata.outputs.title }} POST_SUMMARY: ${{ steps.metadata.outputs.summary }} POST_URL: ${{ steps.metadata.outputs.url }} 구독 폼 구현 (Hugo Shortcode) # \u0026lt;!-- layouts/shortcodes/subscribe.html --\u0026gt; \u0026lt;div class=\u0026#34;subscription-form\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;블로그 구독하기\u0026lt;/h3\u0026gt; \u0026lt;form id=\u0026#34;subscribe-form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; placeholder=\u0026#34;이메일 주소\u0026#34; required\u0026gt; \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;관심 주제 선택 (선택한 주제의 글만 알림)\u0026lt;/legend\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;kubernetes\u0026#34;\u0026gt; Kubernetes\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;docker\u0026#34;\u0026gt; Docker\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;golang\u0026#34;\u0026gt; Go\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;rust\u0026#34;\u0026gt; Rust\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;keywords\u0026#34; value=\u0026#34;devops\u0026#34;\u0026gt; DevOps\u0026lt;/label\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;구독하기\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#39;subscribe-form\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, async (e) =\u0026gt; { e.preventDefault(); const email = document.getElementById(\u0026#39;email\u0026#39;).value; const keywords = Array.from(document.querySelectorAll(\u0026#39;input[name=\u0026#34;keywords\u0026#34;]:checked\u0026#39;)) .map(cb =\u0026gt; cb.value); // Supabase에 저장 const response = await fetch(\u0026#39;https://YOUR_PROJECT.supabase.co/rest/v1/subscribers\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;apikey\u0026#39;: \u0026#39;YOUR_ANON_KEY\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ email, keywords, active: true }) }); if (response.ok) { alert(\u0026#39;구독이 완료되었습니다!\u0026#39;); } else { alert(\u0026#39;오류가 발생했습니다.\u0026#39;); } }); \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; Supabase 함수 (키워드 매칭) # -- 매칭되는 구독자를 찾는 함수 CREATE OR REPLACE FUNCTION get_matching_subscribers(post_tags TEXT) RETURNS TABLE(email TEXT, matched_keywords TEXT[], token TEXT) AS $$ BEGIN RETURN QUERY SELECT s.email, ARRAY( SELECT unnest(s.keywords) INTERSECT SELECT unnest(string_to_array(post_tags, \u0026#39;,\u0026#39;)) ) as matched_keywords, s.unsubscribe_token as token FROM subscribers s WHERE s.active = true AND s.keywords \u0026amp;\u0026amp; string_to_array(post_tags, \u0026#39;,\u0026#39;) -- 배열 겹침 연산자 ; END; $$ LANGUAGE plpgsql; 비용 분석 # SendGrid: 월 100통 무료 (이후 $19.95/월) Supabase: 월 500MB DB, 2GB 전송 무료 GitHub Actions: 월 2,000분 무료 총 비용: 완전 무료 (소규모 블로그) 5. 완전 커스텀 (Supabase + GitHub Actions + Resend) # SendGrid 대안: Resend # SendGrid보다 개발자 친화적인 최신 이메일 API\n장점 # ✅ 무료 티어: 월 3,000통 (SendGrid의 30배!) ✅ 더 간단한 API ✅ React Email 지원 (JSX로 이메일 작성) ✅ 더 나은 개발자 경험 Resend 사용 예시 # import { Resend } from \u0026#39;resend\u0026#39;; const resend = new Resend(process.env.RESEND_API_KEY); await resend.emails.send({ from: \u0026#39;blog@0andwild.github.io\u0026#39;, to: subscriber.email, subject: `새 글: ${title}`, html: `\u0026lt;p\u0026gt;${summary}\u0026lt;/p\u0026gt;\u0026lt;a href=\u0026#34;${url}\u0026#34;\u0026gt;읽기\u0026lt;/a\u0026gt;` }); 비교표 # 방법 무료 한도 키워드 알림 난이도 구독자 관리 커스텀 추천 Blogtrottr 무제한 ❌ ⭐ ❌ ❌ 테스트용 FeedBurner 무제한 ❌ ⭐⭐ ⚠️ ⚠️ 비추천 (지원 중단) Mailchimp 2,000명 ⚠️ (Pro) ⭐⭐ ✅ ⚠️ 일반 구독용 Buttondown 1,000명 ✅ ⭐⭐⭐ ✅ ✅ 개발자용 SendGrid + Actions 100통/월 ✅ ⭐⭐⭐⭐⭐ ✅ ✅✅ 고급 사용자 Resend + Actions 3,000통/월 ✅ ⭐⭐⭐⭐⭐ ✅ ✅✅ 완벽한 통제 추천 로드맵 # 단계 1: 빠른 시작 (즉시) # Mailchimp RSS Campaign\n10분 설정 전체 구독자에게 모든 글 알림 단계 2: 개선 (1주 후) # Buttondown으로 마이그레이션\n더 깔끔한 경험 기본 태그 기능 단계 3: 고급 기능 (필요 시) # Resend + GitHub Actions + Supabase\n키워드 기반 선택적 알림 완전한 통제 확장 가능성 결론 # 일반 블로거라면: # → Mailchimp (가장 쉽고 전문적)\n개발자 블로그라면: # → Buttondown (개발자 친화적, API 제공)\n키워드 알림이 필수라면: # → Resend + GitHub Actions + Supabase (완전 커스텀)\n돈 안 쓰고 테스트하려면: # → Blogtrottr (30초 설정)\n빠른시작 # 실제 구현을 원하신다면:\nMailchimp로 시작 (학습 곡선 낮음) 트래픽 증가 시 Buttondown 고려 고급 기능 필요 시 커스텀 솔루션 구축 키워드 알림은 초기엔 과한 기능일 수 있으니, 기본 구독부터 시작하는 것을 권장합니다.\n","date":"2025-10-17","externalUrl":null,"permalink":"/posts/251017_subscription_alert/","section":"Posts","summary":"RSS Feed, Mailchimp, Buttondown, 커스텀 솔루션까지 - 블로그 구독 시스템의 모든 것","title":"Hugo \u0026 GithubPages 블로그 구독 및 이메일 알림 시스템 구현 가이드","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/rss/","section":"Tags","summary":"","title":"RSS","type":"tags"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/subscription/","section":"Tags","summary":"","title":"Subscription","type":"tags"},{"content":"","date":"2025-10-16","externalUrl":null,"permalink":"/categories/blowfish/","section":"Categories","summary":"","title":"Blowfish","type":"categories"},{"content":"","date":"2025-10-16","externalUrl":null,"permalink":"/series/blowfish/","section":"Series","summary":"","title":"Blowfish","type":"series"},{"content":" 제목 (H2) # 소제목 (H3) # 일반 텍스트입니다. 굵게, 기울임, 취소선\n이미지 삽입 # 방법 1: 로컬 이미지 # 포스트 폴더 내에 이미지 파일을 넣고 사용:\n![이미지 설명](image.jpg) 방법 2: 외부 이미지 URL # ![이미지 설명](https://example.com/image.jpg) 방법 3: HTML 태그 (크기 조정 가능) # \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;이미지 설명\u0026#34; width=\u0026#34;500\u0026#34; /\u0026gt; 캐러셀 이미지 (슬라이드 효과) # 16:9 # Previous Next 21:9 Previous Next # 코드 삽입 # 인라인 코드 # inline code 형식으로 작성\n코드 블록 # package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } def hello(): print(\u0026#34;Hello, World!\u0026#34;) docker run -d -p 8080:80 nginx 링크 # 기본 링크 # 링크 텍스트\n참조 스타일 링크 # 링크 텍스트\narticle 참조 # 리스트 # 순서 없는 리스트 # 항목 1 항목 2 하위 항목 2-1 하위 항목 2-2 항목 3 순서 있는 리스트 # 첫 번째 두 번째 세 번째 체크리스트 # 할 일 1 완료된 일 할 일 2 인용문 # 인용문 내용입니다. 여러 줄도 가능합니다.\n표 (Table) # 항목 설명 비고 A 설명 A 비고 A B 설명 B 비고 B 링크 임베드 (Shortcodes) # YouTube 영상 # {{\u0026lt; youtube VIDEO_ID \u0026gt;}}\nTwitter/X # {{\u0026lt; twitter user=\u0026ldquo;username\u0026rdquo; id=\u0026ldquo;tweet_id\u0026rdquo; \u0026gt;}}\nGitHub Gist # {{\u0026lt; gist username gist_id \u0026gt;}}\n알림 박스 (Blowfish Alert) # {{\u0026lt; alert \u0026ldquo;circle-info\u0026rdquo; \u0026gt;}} 정보 알림입니다. {{\u0026lt; /alert \u0026gt;}}\n{{\u0026lt; alert \u0026ldquo;lightbulb\u0026rdquo; \u0026gt;}} 팁이나 아이디어입니다. {{\u0026lt; /alert \u0026gt;}}\n{{\u0026lt; alert \u0026ldquo;triangle-exclamation\u0026rdquo; \u0026gt;}} 경고 메시지입니다. {{\u0026lt; /alert \u0026gt;}}\n접기/펼치기 (Details) # 클릭하여 펼치기 숨겨진 내용이 여기에 표시됩니다.\n주석 # 수평선 # 위아래로 구분선을 만들 때 사용:\n각주 # 텍스트에 각주1를 추가할 수 있습니다.\n그래프 차트 # Mermaid 차트 # graph LR; A[Lemons]--\u003eB[Lemonade]; B--\u003eC[Profit] Swatched (color showcase) # TypeLt # (Ex1)\n(Ex2)\n(Ex3)\nYoutube Lite # 작성 팁:\nFront matter의 draft: true를 false로 변경하면 배포됩니다 description과 summary를 작성하면 SEO에 도움이 됩니다 이미지는 포스트 폴더에 함께 넣는 것을 권장합니다 각주 내용입니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-16","externalUrl":null,"permalink":"/posts/251016_blowfish_markdown/","section":"Posts","summary":"Blowfish 마크다운 문법 설명서","title":"Hugo markdown 설명서","type":"posts"},{"content":"","date":"2025-10-16","externalUrl":null,"permalink":"/tags/markdown/","section":"Tags","summary":"","title":"Markdown","type":"tags"},{"content":"","date":"2025-10-16","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 블로그 소개 0AndWild Tech Blog에 오신 것을 환영합니다! 이곳은 백엔드 개발, 인프라, 그리고 다양한 기술에 대한 생각과 경험, 배움을 공유하는 공간입니다.\n저는 누구인가요? 3년차 백엔드 개발자로, 새로운 기술을 탐구하고 복잡한 문제를 해결하는 것을 좋아합니다.\n저의 가치관 시간이 걸려도 문제점을 해결했을 때 성취감을 느낍니다. 소통하는 것을 좋아하고 배운 것을 공유할 때 즐거움을 느낍니다. 너무 안정적인 것을 추구하기보다 새로운 길을 개척해나가는 것을 좋아합니다. 실패를 두려워하지 않고 경험이라 생각합니다. 이 블로그에서 다루는 내용 백엔드 개발: 백엔드 아키텍처, 패턴, 모범 사례에 대한 심층 탐구 인프라: DevOps, Docker, Kubernetes, 클라우드 기술 기술 탐험: 새로운 도구와 프레임워크에 대한 실습 경험 연락하기 GitHub LinkedIn Email 방문해 주셔서 감사합니다! 🚀\n","date":"2025-10-16","externalUrl":null,"permalink":"/about/","section":"0AndWild_log","summary":"\u003ch1 class=\"relative group\"\u003e블로그 소개\n    \u003cdiv id=\"블로그-소개\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e0AndWild Tech Blog\u003c/strong\u003e에 오신 것을 환영합니다! 이곳은 백엔드 개발, 인프라, 그리고 다양한 기술에 대한 생각과 경험, 배움을 공유하는 공간입니다.\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003e저는 누구인가요?\n    \u003cdiv id=\"저는-누구인가요\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003e3년차 백엔드 개발자로, 새로운 기술을 탐구하고 복잡한 문제를 해결하는 것을 좋아합니다.\u003c/p\u003e\n\n\u003ch3 class=\"relative group\"\u003e저의 가치관\n    \u003cdiv id=\"저의-가치관\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e시간이 걸려도 문제점을 해결했을 때 성취감을 느낍니다.\u003c/li\u003e\n\u003cli\u003e소통하는 것을 좋아하고 배운 것을 공유할 때 즐거움을 느낍니다.\u003c/li\u003e\n\u003cli\u003e너무 안정적인 것을 추구하기보다 새로운 길을 개척해나가는 것을 좋아합니다.\u003c/li\u003e\n\u003cli\u003e실패를 두려워하지 않고 경험이라 생각합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 class=\"relative group\"\u003e이 블로그에서 다루는 내용\n    \u003cdiv id=\"이-블로그에서-다루는-내용\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e백엔드 개발\u003c/strong\u003e: 백엔드 아키텍처, 패턴, 모범 사례에 대한 심층 탐구\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인프라\u003c/strong\u003e: DevOps, Docker, Kubernetes, 클라우드 기술\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기술 탐험\u003c/strong\u003e: 새로운 도구와 프레임워크에 대한 실습 경험\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 class=\"relative group\"\u003e연락하기\n    \u003cdiv id=\"연락하기\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h2\u003e\n\n\n\n\u003ca\n  class=\"github-button !rounded-md border-2 px-4 py-2 !no-underline inline-block transition-all mr-2 mb-2\"\n  style=\"color: #24292e; border-color: #24292e;\"\n  onmouseover=\"this.style.backgroundColor='rgba(36, 41, 46, 0.1)'\"\n  onmouseout=\"this.style.backgroundColor='transparent'\"\n  href=\"https://github.com/0AndWild\"\n  target=\"_blank\"\n  \n  role=\"button\"\u003e\n  \n\u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 496 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z\"/\u003e\u003c/svg\u003e\u003c/span\u003e GitHub\n\n\u003c/a\u003e\n\u003cstyle\u003e\n  @media (prefers-color-scheme: dark) {\n    .github-button {\n      color: #ffffff !important;\n      border-color: #ffffff !important;\n    }\n  }\n  .dark .github-button {\n    color: #ffffff !important;\n    border-color: #ffffff !important;\n  }\n\u003c/style\u003e\n\n\n\n\n\n\u003ca\n  class=\"!rounded-md border-2 px-4 py-2 !no-underline inline-block transition-all hover:bg-opacity-10 mr-2 mb-2\"\n  style=\"color: #0077b5; border-color: #0077b5;\"\n  onmouseover=\"this.style.backgroundColor='rgba(0, 119, 181, 0.1)'\"\n  onmouseout=\"this.style.backgroundColor='transparent'\"\n  href=\"https://linkedin.com/in/%ea%b1%b4%ec%98%81-%eb%b0%95-158861275\"\n  target=\"_blank\"\n  \n  role=\"button\"\u003e\n  \n\u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z\"/\u003e\u003c/svg\u003e\u003c/span\u003e LinkedIn\n\n\u003c/a\u003e\n\n\n\n\n\n\u003ca\n  class=\"!rounded-md border-2 px-4 py-2 !no-underline inline-block transition-all hover:bg-opacity-10 mr-2 mb-2\"\n  style=\"color: #ea4335; border-color: #ea4335;\"\n  onmouseover=\"this.style.backgroundColor='rgba(234, 67, 53, 0.1)'\"\n  onmouseout=\"this.style.backgroundColor='transparent'\"\n  href=\"mailto:parkky3563@gmail.com\"\n  \n  \n  role=\"button\"\u003e\n  \n\u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1c-27.64 140.9 68.65 266.2 199.1 285.1c19.01 2.888 36.17-12.26 36.17-31.49l.0001-.6631c0-15.74-11.44-28.88-26.84-31.24c-84.35-12.98-149.2-86.13-149.2-174.2c0-102.9 88.61-185.5 193.4-175.4c91.54 8.869 158.6 91.25 158.6 183.2l0 16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98 .0036c-7.299 0-13.2 4.992-15.12 11.68c-24.85-12.15-54.24-16.38-86.06-5.106c-38.75 13.73-68.12 48.91-73.72 89.64c-9.483 69.01 43.81 128 110.9 128c26.44 0 50.43-9.544 69.59-24.88c24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3C495.1 107.1 361.2-9.332 207.8 20.73zM239.1 304.3c-26.47 0-48-21.56-48-48.05s21.53-48.05 48-48.05s48 21.56 48 48.05S266.5 304.3 239.1 304.3z\"/\u003e\u003c/svg\u003e\u003c/span\u003e Email\n\n\u003c/a\u003e\n\n\n\u003chr\u003e\n\u003cp\u003e방문해 주셔서 감사합니다! 🚀\u003c/p\u003e","title":"소개","type":"page"},{"content":"","date":"2022-11-12","externalUrl":null,"permalink":"/categories/ci/cd/","section":"Categories","summary":"","title":"CI/CD","type":"categories"},{"content":"","date":"2022-11-12","externalUrl":null,"permalink":"/tags/ci/cd/","section":"Tags","summary":"","title":"CI/CD","type":"tags"},{"content":"","date":"2022-11-12","externalUrl":null,"permalink":"/tags/external/","section":"Tags","summary":"","title":"External","type":"tags"},{"content":"","date":"2022-11-12","externalUrl":null,"permalink":"/categories/jenkins/","section":"Categories","summary":"","title":"Jenkins","type":"categories"},{"content":"","date":"2022-11-12","externalUrl":null,"permalink":"/tags/jenkins/","section":"Tags","summary":"","title":"Jenkins","type":"tags"},{"content":"","date":"2022-11-12","externalUrl":null,"permalink":"/series/jenkins--springboot-ci/cd/","section":"Series","summary":"","title":"Jenkins \u0026 Springboot CI/CD","type":"series"},{"content":"","date":"2022-11-12","externalUrl":"https://0andwild.tistory.com/38","permalink":"/posts/221112_jenkins_springboot/","section":"Posts","summary":"Jenkins \u0026amp; Springboot CI/CD 를 구축하는 방법에 대해 다룹니다.","title":"Jenkins \u0026 Springboot CI/CD 정리 마지막 (4)","type":"posts"},{"content":"","date":"2022-11-12","externalUrl":null,"permalink":"/categories/springboot/","section":"Categories","summary":"","title":"Springboot","type":"categories"},{"content":"","date":"2022-11-12","externalUrl":null,"permalink":"/tags/springboot/","section":"Tags","summary":"","title":"Springboot","type":"tags"},{"content":"","date":"2022-11-11","externalUrl":"https://0andwild.tistory.com/37","permalink":"/posts/221111_jenkins_springboot2/","section":"Posts","summary":"Jenkins \u0026amp; Springboot CI/CD 를 구축하는 방법에 대해 다룹니다.","title":"Jenkins \u0026 Springboot CI/CD 정리 (3)","type":"posts"},{"content":"","date":"2022-11-11","externalUrl":"https://0andwild.tistory.com/36","permalink":"/posts/221111_jenkins_springboot/","section":"Posts","summary":"Jenkins \u0026amp; Springboot CI/CD 를 구축하는 방법에 대해 다룹니다.","title":"Jenkins \u0026 Springboot CI/CD 정리 (2)","type":"posts"},{"content":"","date":"2022-11-05","externalUrl":"https://0andwild.tistory.com/35","permalink":"/posts/221105_jenkins_springboot/","section":"Posts","summary":"Jenkins \u0026amp; Springboot CI/CD 를 구축하는 방법에 대해 다룹니다.","title":"Jenkins \u0026 Springboot CI/CD 정리 (1)","type":"posts"},{"content":"","date":"2022-11-03","externalUrl":null,"permalink":"/tags/checkstyle/","section":"Tags","summary":"","title":"CheckStyle","type":"tags"},{"content":"","date":"2022-11-03","externalUrl":null,"permalink":"/categories/devops/","section":"Categories","summary":"","title":"DevOps","type":"categories"},{"content":"","date":"2022-11-03","externalUrl":null,"permalink":"/series/jenkins--sornaqube--checkstyle/","section":"Series","summary":"","title":"Jenkins \u0026 Sornaqube \u0026 CheckStyle","type":"series"},{"content":"","date":"2022-11-03","externalUrl":"https://0andwild.tistory.com/34","permalink":"/posts/221103_jenkins_sornaqube/","section":"Posts","summary":"Jenkins \u0026amp; Sornaqube \u0026amp; CheckStyle 을 이용한 코드컨벤션 적용 방법을 다룹니다.","title":"Jenkins\u0026Sonaqube\u0026Checkstyle 을 이용한 코드컨벤션 적용기(Naver Code Convention)","type":"posts"},{"content":"","date":"2022-11-03","externalUrl":null,"permalink":"/tags/sornaqube/","section":"Tags","summary":"","title":"Sornaqube","type":"tags"},{"content":"","date":"2022-10-27","externalUrl":null,"permalink":"/tags/integration/","section":"Tags","summary":"","title":"Integration","type":"tags"},{"content":"","date":"2022-10-27","externalUrl":"https://0andwild.tistory.com/33","permalink":"/posts/221027_jenkins_slack/","section":"Posts","summary":"Jenkins와 Slack을 연동하여 CI/CD 파이프라인의 각 stage별 빌드 성공/실패 알림을 Slack으로 받는 방법을 단계별로 설명합니다.","title":"Jenkins \u0026 Slack Notification 연동","type":"posts"},{"content":"","date":"2022-10-27","externalUrl":null,"permalink":"/series/jenkins_slack_notification/","section":"Series","summary":"","title":"Jenkins_Slack_Notification","type":"series"},{"content":"","date":"2022-10-27","externalUrl":null,"permalink":"/tags/notification/","section":"Tags","summary":"","title":"Notification","type":"tags"},{"content":"","date":"2022-10-27","externalUrl":null,"permalink":"/tags/slack/","section":"Tags","summary":"","title":"Slack","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/apache/","section":"Tags","summary":"","title":"Apache","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/categories/infrastructure/","section":"Categories","summary":"","title":"Infrastructure","type":"categories"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/load-balancing/","section":"Tags","summary":"","title":"Load Balancing","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/series/nginx/","section":"Series","summary":"","title":"Nginx","type":"series"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/nginx/","section":"Tags","summary":"","title":"Nginx","type":"tags"},{"content":" Nginx란? # Nginx(엔진엑스)는 경량 고성능 웹 서버 소프트웨어입니다. 웹 서버로 동작할 뿐만 아니라 리버스 프록시, 로드 밸런서, HTTP 캐시로도 사용됩니다.\nNginx는 높은 동시 접속 처리를 위해 설계되었으며, 현재 전 세계 수많은 대규모 웹사이트에서 사용되고 있습니다.\n왜 Nginx가 필요했을까? # 과거에는 Apache 웹서버가 업계 표준이었습니다. 하지만 2000년대 초반, 인터넷 사용자가 폭발적으로 증가하면서 C10k 문제라는 병목 현상이 발생했습니다.\nC10k 문제 # C10k 문제는 \u0026ldquo;Connection 10,000\u0026quot;의 약자로, 하나의 서버에서 동시에 10,000개의 클라이언트 연결을 처리하는 것을 의미합니다.\n중요한 개념 구분\n동시 처리 (Concurrent): 많은 연결을 동시에 유지하고 관리 처리 속도 (Throughput): 초당 처리할 수 있는 요청의 개수 동시 접속 처리는 빠른 속도보다는 효율적인 자원 관리와 스케줄링이 핵심입니다.\nApache의 구조적 한계 # 기존 Apache는 다음과 같은 구조적 문제를 가지고 있었습니다:\n1. 프로세스 기반 처리 # 요청이 들어올 때마다 새로운 프로세스 또는 스레드를 생성 사용자가 많아질수록 프로세스 수가 비례 증가 결과적으로 메모리 부족 발생 2. 높은 리소스 소비 # Apache의 강력한 확장성 덕분에 다양한 모듈 추가 가능 하지만 각 프로세스가 모든 모듈을 메모리에 로드 프로세스당 메모리 사용량 증가 3. Context-Switching 오버헤드 # CPU 코어가 여러 프로세스를 번갈아 실행 프로세스 전환 시 Context-Switching 비용 발생 요청이 많을수록 CPU 오버헤드 증가 이러한 문제로 인해 Apache는 대규모 동시 접속 환경에 부적합했습니다.\nNginx의 탄생 # 2002년, 러시아의 개발자 **이고르 시쇼브(Igor Sysoev)**가 이 문제를 해결하기 위해 Nginx 개발을 시작했고, 2004년 첫 릴리즈를 공개했습니다.\nNginx의 핵심 목표 # 높은 동시 접속 처리 낮은 메모리 사용량 높은 성능과 안정성 Nginx의 주요 역할 # HTTP Server: 정적 파일(HTML, CSS, JS, 이미지)을 빠르게 제공 Reverse Proxy Server: 백엔드 애플리케이션 서버 앞단에서 요청 중계 Load Balancer: 여러 서버로 트래픽 분산 Mail Proxy Server: 메일 서버 프록시 기능 Nginx의 내부 구조 # Nginx는 1개의 Master Process와 여러 개의 Worker Process로 구성됩니다.\nMaster Process의 역할 # Master Process는 다음 작업을 담당합니다:\n설정 파일 읽기 및 유효성 검증 Worker Process 생성 및 관리 설정 변경 시 Worker Process 재시작 # Master Process 확인 ps aux | grep nginx Worker Process의 역할 # Worker Process가 실제 클라이언트 요청을 처리합니다:\n1. 커넥션 관리 # Master Process로부터 listen socket 할당받음 클라이언트와 커넥션 형성 Keep-Alive 시간 동안 커넥션 유지 하나의 Worker가 수천 개의 커넥션 동시 처리 2. Non-blocking I/O # 커넥션에 요청이 없으면 다른 작업 처리 요청이 들어오면 즉시 응답 비동기 Event-Driven 방식으로 효율적 처리 3. Thread Pool # 시간이 오래 걸리는 작업(파일 I/O, DB 쿼리)은 Thread Pool에 위임 Worker Process는 다른 요청 계속 처리 Blocking 작업의 영향 최소화 4. CPU 코어 최적화 # Worker Process는 CPU 코어 개수만큼 생성 권장 각 Worker를 특정 CPU 코어에 고정 (CPU Affinity) Context-Switching 최소화로 성능 향상 # nginx.conf 설정 예시 worker_processes auto; # CPU 코어 수만큼 자동 생성 worker_cpu_affinity auto; # CPU 친화성 자동 설정 Event-Driven 아키텍처 # Nginx는 멀티프로세스 + 싱글스레드 + Event-Driven 방식으로 동작합니다:\n여러 커넥션을 Event Handler가 관리 비동기 Non-blocking 방식으로 처리 먼저 준비된 이벤트부터 순차 처리 대기 중인 프로세스 없이 자원 효율성 극대화 이는 Apache처럼 요청을 기다리며 방치되는 프로세스가 없어 메모리와 CPU를 효율적으로 사용합니다.\nNginx의 장단점 # 장점 # 1. 높은 동시 접속 처리 능력 # Apache 대비 동시 커넥션 수 10배 이상 증가 동일 커넥션에서 처리 속도 2배 향상 2. 낮은 리소스 사용 # 적은 수의 프로세스로 동작 메모리 사용량 최소화 경량 구조로 빠른 응답 속도 3. 무중단 설정 리로드 # nginx -s reload # 서비스 중단 없이 설정 적용 Master Process가 새 설정 읽기 기존 Worker는 현재 요청 완료 후 종료 새 Worker가 새 설정으로 요청 처리 서비스 중단 없이 설정 변경 가능 4. 우수한 정적 파일 처리 # 이미지, CSS, JS 등 정적 콘텐츠를 빠르게 제공 Apache보다 정적 파일 처리 성능 우수 단점 # 1. 동적 모듈 개발의 어려움 # 모듈 추가 시 Worker Process 재시작 필요 Apache처럼 손쉬운 모듈 개발 어려움 대신 Lua 스크립팅으로 어느 정도 보완 가능 2. Windows 환경 제한 # Linux/Unix 환경에 최적화 Windows에서는 성능과 안정성 저하 프로덕션 환경에서는 Linux 사용 권장 3. .htaccess 미지원 # Apache의 .htaccess 파일 사용 불가 모든 설정을 중앙 설정 파일에서 관리 호스팅 환경에서 유연성 떨어질 수 있음 Nginx의 주요 기능 # 1. 리버스 프록시 (Reverse Proxy) # 리버스 프록시는 클라이언트와 백엔드 서버 사이에서 중계자 역할을 합니다.\n주요 이점 # 보안 강화: 실제 서버 IP 숨김 캐싱: 자주 요청되는 응답 캐싱 압축: 응답 데이터 압축으로 대역폭 절약 SSL 처리: HTTPS 암호화/복호화 담당 # 리버스 프록시 설정 예시 location / { proxy_pass http://backend_server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } 실무 활용 패턴 # Nginx + Apache: Nginx가 정적 파일 처리, Apache가 동적 처리 Nginx + Node.js/Python/Java: Nginx가 프론트엔드, 백엔드 애플리케이션 보호 Nginx + Nginx: 여러 Nginx 서버를 계층적으로 구성 2. 로드 밸런싱 (Load Balancing) # 여러 백엔드 서버로 트래픽을 분산하여 부하를 균등하게 배분합니다.\n로드 밸런싱 알고리즘 # Round Robin (기본값) # 순차적으로 요청을 각 서버에 분배 가장 간단하고 공평한 방식 upstream backend { server backend1.example.com; server backend2.example.com; server backend3.example.com; } Least Connections # 현재 연결 수가 가장 적은 서버로 전송 처리 시간이 다른 요청에 적합 upstream backend { least_conn; server backend1.example.com; server backend2.example.com; } IP Hash # 클라이언트 IP 해시값으로 서버 결정 세션 유지(Session Persistence)에 유용 upstream backend { ip_hash; server backend1.example.com; server backend2.example.com; } Weight (가중치) # 서버 성능에 따라 가중치 부여 고성능 서버에 더 많은 요청 전달 upstream backend { server backend1.example.com weight=3; server backend2.example.com weight=2; server backend3.example.com weight=1; } Health Check (헬스 체크) # upstream backend { server backend1.example.com max_fails=3 fail_timeout=30s; server backend2.example.com max_fails=3 fail_timeout=30s; } max_fails: 실패 허용 횟수 fail_timeout: 서버를 다운으로 간주할 시간 장애 서버 자동 제외로 가용성 향상 3. SSL/TLS 터미네이션 # Nginx가 클라이언트와 HTTPS 통신, 백엔드와 HTTP 통신을 담당합니다.\n주요 이점 # 백엔드 서버의 SSL 처리 부담 제거 중앙화된 인증서 관리 백엔드는 비즈니스 로직에 집중 Nginx와 백엔드는 같은 내부 네트워크에서 HTTP 통신 (보안상 안전) server { listen 443 ssl http2; server_name example.com; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/key.pem; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://backend; } } HTTP/2 지원 # Nginx는 HTTP/2를 지원하여:\n멀티플렉싱: 하나의 커넥션으로 여러 요청 동시 처리 헤더 압축: 대역폭 절약 Server Push: 클라이언트 요청 전 리소스 전송 4. 캐싱 (Caching) # 서버 응답을 메모리나 디스크에 저장하여 반복 요청 시 빠르게 응답합니다.\n# 캐시 경로 설정 proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=1g; server { location / { proxy_cache my_cache; proxy_cache_valid 200 60m; # 200 응답은 60분 캐싱 proxy_cache_valid 404 10m; # 404 응답은 10분 캐싱 proxy_pass http://backend; } } 캐싱 전략 # 프록시 캐싱: 백엔드 응답 캐싱 FastCGI 캐싱: PHP-FPM 등 동적 콘텐츠 캐싱 정적 파일 캐싱: 브라우저 캐시 헤더 설정 # 정적 파일 캐시 헤더 설정 location ~* \\.(jpg|jpeg|png|gif|ico|css|js)$ { expires 1y; add_header Cache-Control \u0026#34;public, immutable\u0026#34;; } 5. 압축 (Gzip) # 응답 데이터를 압축하여 네트워크 대역폭 절약\ngzip on; gzip_vary on; gzip_min_length 1024; gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json application/javascript; 텍스트 기반 콘텐츠 60-80% 압축 전송 시간 단축으로 사용자 경험 개선 6. Rate Limiting (속도 제한) # DDoS 공격 방어 및 서버 보호\n# Zone 정의 limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s; server { location /api/ { limit_req zone=mylimit burst=20 nodelay; proxy_pass http://backend; } } IP당 초당 요청 수 제한 burst: 순간적인 트래픽 증가 허용 API 서버 보호에 필수적 Nginx vs Apache: 어떤 것을 선택할까? # Nginx를 선택해야 하는 경우 # 높은 동시 접속 처리가 필요한 경우 정적 파일 서비스가 주요 목적인 경우 리버스 프록시/로드 밸런서가 필요한 경우 리소스 효율성이 중요한 경우 최신 프로토콜(HTTP/2, HTTP/3) 지원 필요 Apache를 선택해야 하는 경우 # .htaccess 파일 기반 설정이 필요한 경우 다양한 써드파티 모듈이 필요한 경우 Windows 환경에서 사용해야 하는 경우 레거시 애플리케이션 호환성이 중요한 경우 동적 모듈 개발이 빈번한 경우 최적의 조합: Nginx + Apache # 많은 기업이 Nginx를 프론트엔드, Apache를 백엔드로 사용합니다:\n[클라이언트] → [Nginx] → [Apache] → [애플리케이션] 정적 파일 동적 처리 SSL 처리 PHP/Python 캐싱 모듈 활용 실무 팁 # 1. Worker Connections 설정 # events { worker_connections 1024; # Worker당 처리 가능한 커넥션 수 use epoll; # Linux에서 최적의 이벤트 모델 } 2. Keepalive 최적화 # http { keepalive_timeout 65; keepalive_requests 100; } 3. 버퍼 크기 조정 # http { client_body_buffer_size 16K; client_header_buffer_size 1k; client_max_body_size 8m; large_client_header_buffers 4 8k; } 4. 로그 최적화 # http { access_log /var/log/nginx/access.log combined buffer=32k; error_log /var/log/nginx/error.log warn; } 5. 보안 강화 # # 버전 정보 숨기기 server_tokens off; # 보안 헤더 추가 add_header X-Frame-Options \u0026#34;SAMEORIGIN\u0026#34; always; add_header X-Content-Type-Options \u0026#34;nosniff\u0026#34; always; add_header X-XSS-Protection \u0026#34;1; mode=block\u0026#34; always; 마무리 # Nginx는 현대 웹 인프라의 핵심 구성 요소로 자리잡았습니다. Event-Driven 아키텍처를 통한 높은 성능과 효율성으로 Netflix, Airbnb, GitHub 등 대규모 서비스에서 사용되고 있습니다.\nApache의 안정성과 확장성도 여전히 가치가 있지만, 대규모 트래픽 처리와 리소스 효율성이 중요한 현대 웹 환경에서는 Nginx가 더 적합한 선택입니다.\n추천 학습 경로\n로컬 환경에서 Nginx 설치 및 기본 설정 실습 리버스 프록시 구성해보기 로드 밸런싱 설정 및 테스트 SSL 인증서 적용 (Let\u0026rsquo;s Encrypt) 성능 모니터링 및 최적화 참고 자료 # Nginx 공식 문서 Nginx 설정 생성기 Nginx Performance Tuning Guide 다만 주의할 점: Nginx는 Windows 환경에서 제한적인 성능과 호환성을 보이므로, 프로덕션 환경에서는 반드시 Linux/Unix 시스템을 사용하는 것을 권장합니다!\n","date":"2022-10-25","externalUrl":null,"permalink":"/posts/221025_about_nginx/","section":"Posts","summary":"고성능 웹 서버 Nginx의 개념, Apache와의 비교, Event-Driven 구조, 그리고 실무에서 활용되는 주요 기능들을 정리한 가이드","title":"Nginx란 무엇일까? 웹 서버의 진화와 구조","type":"posts"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/performance/","section":"Tags","summary":"","title":"Performance","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/reverse-proxy/","section":"Tags","summary":"","title":"Reverse Proxy","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/ssl/","section":"Tags","summary":"","title":"SSL","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/categories/web-server/","section":"Categories","summary":"","title":"Web Server","type":"categories"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/web-server/","section":"Tags","summary":"","title":"Web Server","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/cli/","section":"Tags","summary":"","title":"CLI","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/container/","section":"Tags","summary":"","title":"Container","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/series/deep-dive-into-docker/","section":"Series","summary":"","title":"Deep Dive Into Docker","type":"series"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/devops/","section":"Tags","summary":"","title":"DevOps","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/categories/docker/","section":"Categories","summary":"","title":"Docker","type":"categories"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/installation/","section":"Tags","summary":"","title":"Installation","type":"tags"},{"content":"","date":"2022-10-25","externalUrl":null,"permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"Ubuntu","type":"tags"},{"content":" 지난 글에 이어 도커의 명령어와 사용방법을 정리해볼까 합니다 =)\nDocker 설치하기 # 우선 도커를 사용하려면 설치를 해주어야 겠죠?\n필자의 경우 AWS EC2 인스턴스로 Ubuntu 환경에서 Docker를 설치하였습니다.\nUbuntu 및 다른 환경에서 설치가 필요하신 경우 아래 공식 문서를 참고해주세요!\nInstall Docker Engine on Ubuntu - docs.docker.com\nDocker 구버전 제거 및 신버전 설치 # 만약 Docker 구버전을 삭제 후 신버전을 설치하려 한다면 아래 명령어를 통해 구버전을 삭제해주도록 합니다.\nUbuntu 기준\nsudo apt-get remove docker docker-engine docker.io containerd runc 저장소 업데이트\nsudo apt-get update apt가 https를 통해 repository를 사용할 수 있도록 패키지 설치\nsudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common Docker 저장소 키를 apt에 등록\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - Docker 저장소 등록\nsudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; 지금까지 작업 내용 반영을 위해 apt update\nsudo apt-get update Docker 설치\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin 위의 명령어를 통해 Docker 설치 작업을 끝냈다면 확인을 해봐야 겠죠?!\nsudo docker version 또는\nsudo docker run hello-world 위와 같이 run 명령어를 사용하면 hello-world 이미지를 local에서 찾고 만약 없으면 docker hub에서 이미지를 다운받고 실행시켜 컨테이너로 띄워질 것입니다 =)\nDocker 권한 설정 # 만약 도커 명령어 실행시 다음과 같은 문구가 나온다면 걱정하지 마세요 ㅎㅎ\n이 메세지는 Docker를 root 외의 사용자가 사용할 수 있는 권한이 없어 그런 것 입니다 =)\n우선 docker의 권한을 확인합니다.\ncat /etc/group | grep docker 필자의 경우 이미 사용자 권한을 추가하여 뒤에 ubuntu 라는 사용자 이름으로 권한이 추가되어 있습니다.\n만약 추가가 되어 있지 않다면 docker:x:999: 와 같은 문구를 확인할 수 있을 겁니다!\nDocker 그룹에 사용할 사용자 아이디를 추가해줍니다\nsudo usermod -aG docker [사용자이름] 사용자이름은 예시로 필자는 위의 사진과 같이 ubuntu라는 사용자 이름으로 사용중이기에 ubuntu를 넣어 주었습니다.\nLinux의 경우 기본유저이름이 ec2-user로 잡혀 있을 겁니다 =)\n시스템 재시작을 해줍니다.\nsudo reboot 이제 docker 명령어 앞에 sudo 를 빼고 다시 버전확인을 해보도록 하겠습니다.\ndocker version 다음과 같이 Client와 Server 정보가 나오면 정상적으로 권한 부여가 이루어진겁니다. =)\n만약 Got permission denied ... 메세지가 다시 나온다면 권한 설정이 잘 이루어지지 않을 것이니 확인을 다시 해보신 후 추가적인 에러메세지를 함께 검색해보시길 바랍니다!\n에러메세지를 댓글에 공유 해주시면 저도 함께 찾아보도록 하겠습니다 ㅎㅎ\nWindows \u0026amp; Mac OS Docker Desktop # + 추가적으로 Windows 와 Mac OS의 경우 docker desktop을 지원하여 간편한 설치를 통해 GUI를 사용할 수 있습니다!\n개인 사용자나 250인 이하 또는 $1000만 달러 미만 매출의 회사에서만 무료로 사용할 수 있다니 참고 바랍니다!\n설치방법은 아래 공식문서 링크를 참고하세요 =)\nInstall Docker Desktop on Windows - docs.docker.com\nInstall Docker Desktop on Mac - docs.docker.com\nDocker 명령어 # Docker Image 검색 # Docker 공식 registry인 Docker hub에서 이미지를 검색합니다.\nsudo docker search [검색 할 Image이름] 이미지 다운받기 # sudo docker pull [이미지이름]:[태그] 일반적으로 이미지 생성시 태그명을 따로 지정하지 않으면 default 값으로 latest가 붙습니다 =)\n이미지를 docker hub 계정에 push 하기 # 필자의 경우 좀전에 받은 hello-world 이미지를 필자의 docker-hub 계정에 push 해보도록 하겠습니다.\n먼저 push를 하기에 앞서 docker-hub에 hello-world 라는 repository를 만들어두도록 하겠습니다.\nsudo docker push [docker-hub ID]/[이미지 이름]:[태그] 음\u0026hellip; 다음과 같은 메세지와 함께 이미지 push가 실패하였네요. =(\n이러한 이유는 docker hub의 repository 이름과 로컬의 도커 이미지 repository 이름을 똑같게 해줘야 한다고 합니다.\n해결방법\nsudo docker image tag [이미지 repo 이름]:[태그] [변경할 이미지 repo이름 지정]:[태그] 이 방식은 해당 이미지의 이름을 바꾸는 것이 아닌 이미지를 복사하여 새로운 이름의 이미지를 생성해줍니다. =)\n필자의 경우 tag 부분은 변경할 repo 도 default인 latest를 사용할거기 때문에 따로 지정을 해주지 않았습니다.\n다시 push를 해보도록 하겠습니다 ㅎㅎ.\n이제 정상적으로 이미지가 push 된 것을 확인할 수 있습니다! =)\n다운받은 이미지 확인 # sudo docker images Docker image를 실행하여 container로 띄우기 # docker run -d -i -t --name [생성할 컨테이너 name 설정] -p [host port:container port] [image name or ID] 필자의 경우 이미 springboot project를 docker image로 빌드 해둔 것이 있어 해당 image를 실행시켜 컨테이너로 띄워보도록 하겠습니다. =)\n일반적으로는 -i -t 옵션을 함께 사용하여 -it 이렇게 옵션을 주기도 합니다 =)\nhost port는 컨테이너가 띄워진 후 사용자가 접근할 외부 port이고 container port는 다음과 같이 docker file을 이용하여 docker image를 빌드할때 지정해준 port라 생각하시면 될 것 같습니다. =)\n필자의 경우 이미지를 생성할 때 .yml 파일에 존재하는 local, dev, prod 환경 중 dev환경으로 지정해주었고 해당 dev 환경의 server port는 8081로 지정해주었기 때문에 containerport를 8081로 지정해주었습니다!\nimage name or ID 는 실행시킬 이미지의 이름 또는 해당 이미지의 아이디 값을 넣어주면 됩니다. =)\nDocker의 다양한 옵션에 대한 내용은 아래에 정리를 해두었으니 참고 바랍니다 !\n이제 이미지를 실행 시켰으니 컨테이너가 잘 띄워 졌는지 확인을 해봐야 겠죠?\n실행중인 컨테이너 확인 # sudo docker ps 컨테이너가 실행된 후 http://[public ip]:8080 으로 접속을 하니 서버가 잘 띄워진 것을 확인 할 수 있습니다! =)\n또한 현재 띄워진 서버의 운영 환경이 dockerfile에서 지정해준 dev1 환경이라는 것을 만들어둔 api를 통해 확인할 수 있었습니다. =)\n포트 매핑 실험 # 그럼 여기서 추가적으로 실험을 하나더 해보도록 하겠습니다. 필자는 아까 말했듯이 docker file에서 dev1으로 운영환경을 지정해주었고 해당 dockerfile을 통해 빌드된 이미지는 내부적으로 server port가 8081 인 이미지 입니다.\n그럼 이 이미지를 실행시킬 때 -p 8080:8080 으로 container port를 8081이 아닌 8080으로 주게되면 어떻게 될까요??\n우선 컨테이너는 정상적으로 띄워졌군요!\n그럼 해당 서버의 ip와 외부접근 port인 8080으로 접근을 시도해보도록 하겠습니다!\n이번에는 컨테이너는 정상적으로 띄워 졌지만 서버는 제대로 작동을 하지 않는 것 같군요 =)\n이렇게 dockerfile에서 설정한 운영환경 지정이 제대로 동작하는 것을 확인 할 수 있습니다!\n기본적인 Docker 명령어 # $ sudo docker pull [다운받을 이미지 이름]:[태그] $ sudo docker push [docker-hub ID]/[이미지 이름]:[태그] $ docker images # pull 또는 run을 통해 다운받아 local에 존재하는 image들을 확인할 수 있음 $ docker run -d -i -t --name [생성할 컨테이너 name 설정] -p [host port:container port] [image name or ID] # Docker image를 실행하여 컨테이너로 띄움. 만약 docker hub에 존재하는 공식이미지의 경우 # pull을 미리 하지 않고도 local에 없으면 자동으로 다운받아 실행시켜줌. $ sudo docker ps # 이미지를 실행시켜 컨테이너로 띄워지고 실행중인 컨테이너 항목들을 보여줌 $ sudo docker ps -a # 실행중인 컨테이너 외에 종료된 컨테이너 항목들을 모두 보여줌 $ sudo docker stop [컨테이너이름 or 컨테이너 ID] # 현재 실행중인 컨테이너를 중지시킴 $ sudo docker start [컨테이너 이름 or 컨테이너 아이디] # 종료된 컨테이너를 실행시킴 $ sudo docker restart [컨테이너이름 or 컨테이너 ID] # 실행중인 컨테이너를 재시작함 $ sudo docker rm [컨테이너 이름 or 컨테이너 ID] # 컨테이너를 삭제시킴 # 컨테이너를 삭제시키기 위해선 먼저 컨테이너를 stop 해주어야 합니다 =) # +tip 컨테이너 ID를 입력할 경우 모두 적지 않고 2~3글자만 적어도 됩니다. $ sudo docker rmi [이미지이름 or 이미지 ID] # 이미지를 삭제합니다. # 이또한 마찬가지로 ID를 이용해 삭제할경우 2~3글자만 입력하여도 됩니다 =) $ sudo docker logs [컨테이너이름 or 컨테이너 ID] # 실행한 컨테이너의 로그를 확인할 수 있습니다 $ sudo docker exec -it [컨테이너ID] /bin/bash # 컨테이너 내부 접근 # 종료시에는 $ exit Docker 명령어 옵션 # -i : --interactive : 표준입력을 활성화하며, 컨테이너와 연결(attach)되어 있지 않더라도 표준입력을 유지함. 이 옵션을 통해 Bash 명령어를 입력함.\n-t : --tty : TTY(pseudo-TTY)를 사용함. Bash를 사용하려면 이 옵션을 설정해야하고 설정하지 않으면 명령어를 입력할 순 있지만 셸이 표시되지 않음.\n-d : --detach : Detached 모드로 데몬 모드라고 부릅니다. 컨테이너가 백그라운드로 실행됩니다.\n-p : --publish : 호스트와 컨테이너 포트를 연결합니다. (포트포워딩) ex) -p 80:80\n\u0026ndash;privileged : 컨테이너 안에서 호스트의 리눅스 커널 기능(Capability)을 모두 사용합니다. 이를통해 호스트의 주요 자원에 접근할 수 있음\n\u0026ndash;rm : 프로세스 종료시 컨테이너 자동 제거\n\u0026ndash;restart : 컨테이너 종료 시, 재시작 정책을 설정합니다.\n-v : --volume : 데이터 볼륨설정으로 호스트와 컨테이너의 디렉토리를 연결하여, 파일 설정등을 호스트에서 변경하면 컨테이너 내부도 동일하게 변경사항이 적용됩니다. 싱크의 개념.\n-u : --user : 컨테이너가 실행될 리눅스 사용자 계정 이름 또는 UID를 설정합니다.\nex) --user ubuntu -e : --env : 컨테이너 내부에서 사용할 환경변수를 설정합니다. 일반적으로 설정값이나 비밀번호를 전달할 때 사용합니다.\n\u0026ndash;link : 컨테이너끼리 연결합니다. [컨테이너명:별칭]\nex) --link \u0026quot;mysql:mysql\u0026quot; -h : --hostname : 컨테이너의 호스트 이름을 설정합니다.\n-w : --workdir : 컨테이너 안의 프로세스가 실행될 디렉토리를 설정합니다.\n-a : --attach : 컨테이너에 표준입력(stdin), 표준출력(stdout), 표준에러(stderr)를 연결합니다.\n-c : --cpu-shares : CPU 자원 분배 설정입니다. 기본값은 1024이고 각 값은 상대적으로 적용됩니다.\n-m : --memory : 메모리 한계를 설정합니다.\nex) --memory=\u0026quot;100m\u0026quot; \u0026ndash;gpus : 컨테이너에서 호스트의 NVIDIA GPU 를 사용할 수 있도록 설정합니다. 이 방식을 사용하기 위해선 호스트는 NVIDIA GPU가 장착된 Linux 서버 + NVIDIA driver 설치 완료 + docker 19.03.5 버전 이상이여야 합니다\n--gpus all : GPU 모두 사용하기 --gpus \u0026quot;device=0.1\u0026quot; : GPU 지정하여 사용 \u0026ndash;security-opt : SELinux, AppArmor 옵션을 설정합니다.\n--security-opt=\u0026quot;label:level:TopSecret\u0026quot; ","date":"2022-10-25","externalUrl":null,"permalink":"/posts/221025_docker_command/","section":"Posts","summary":"Docker 설치부터 이미지 관리, 컨테이너 실행까지 필수 명령어와 옵션을 상세히 정리한 실전 가이드","title":"도커(Docker) 설치 \u0026 명령어 사용방법 총정리","type":"posts"},{"content":"","date":"2022-10-24","externalUrl":null,"permalink":"/tags/virtualization/","section":"Tags","summary":"","title":"Virtualization","type":"tags"},{"content":"","date":"2022-10-24","externalUrl":null,"permalink":"/tags/%EA%B0%80%EC%83%81%ED%99%94/","section":"Tags","summary":"","title":"가상화","type":"tags"},{"content":" Docker는 오픈소스 컨테이너화 플랫폼으로, 코드와 의존성을 패키징하여 다양한 컴퓨팅 환경에서 애플리케이션을 빠르고 안정적으로 실행할 수 있게 해줍니다. 🐳 Docker란? # Docker의 핵심 개념은 크게 두 가지입니다: 컨테이너(Container) 와 이미지(Image)\nDocker Image (도커 이미지) # Docker Image는 애플리케이션 실행에 필요한 코드, 런타임, 시스템 도구, 시스템 라이브러리, 설정 등을 포함하는 경량의 독립적인 소프트웨어 패키지입니다. 실제 사용 예시 # 기존 방식으로 Linux에 Jenkins를 설치한다면:\n$ sudo apt-get install jenkins 위 명령어를 실행하면 여러 의존성 패키지들을 함께 다운로드해야 합니다.\n반면 Docker를 사용하면:\n$ docker pull jenkins/jenkins:lts 필요한 모든 구성 요소가 포함된 사전 구성된 이미지를 한 번에 다운로드할 수 있습니다.\n📦 Docker Registry \u0026amp; Docker Hub # Docker Registry는 Docker 이미지를 공유하는 저장소 역할을 합니다. \u0026ldquo;Docker용 GitHub\u0026quot;라고 생각하면 쉽습니다. Docker Hub는 공식 Docker 레지스트리로, 벤더가 제공하는 공식 이미지들을 제공합니다.\n동작 흐름 # 사용자가 레지스트리에서 이미지를 다운로드 이미지를 컨테이너로 실행 하나의 컴퓨터에서 여러 개의 격리된 환경 구성 가능 🔄 Container Virtualization (컨테이너 가상화) # 컨테이너 기술은 \u0026ldquo;하나의 시스템 내에서 여러 개의 격리된 인스턴스를 실행할 수 있게 하는 서버 가상화 방식\u0026quot;으로, 각 컨테이너는 사용자에게 개별 서버처럼 보입니다. 중요한 점: 컨테이너는 Docker만의 전유물이 아닙니다. OpenVZ, Libvirt, LXC 등 다양한 컨테이너 기술이 존재합니다.\n🖥️ 가상화 방식의 종류 # 1. Host Virtualization (호스트 가상화) # 구조: Guest OS가 Host OS 위에서 가상화 소프트웨어를 통해 실행됩니다.\n예시: VM Workstation, VMware Player, VirtualBox 등 장점:\n설치 및 구성이 간단함 하드웨어 에뮬레이션으로 최소한의 호스트 요구사항 단점:\nOS 위에 OS를 실행하므로 리소스 집약적 성능 오버헤드가 큼 2. Hypervisor Virtualization (하이퍼바이저 가상화) # 구조: Host OS 없이 하드웨어에 직접 소프트웨어를 설치하여 실행합니다.\n하이퍼바이저 가상화의 두 가지 접근 방식:\n1) Full Virtualization (전가상화) # Guest OS가 하드웨어에 직접 접근하지 않고 하이퍼바이저를 통해 접근 더 안정적이지만 성능 오버헤드 존재 2) Paravirtualization (반가상화) # Guest OS가 하이퍼바이저를 통해 하드웨어에 직접 접근 더 빠르지만 OS 수정 필요 장점:\nHost OS가 없어 더 효율적 리소스를 더 효과적으로 활용 단점:\n시작 시간이 느림 각 VM이 독립적인 OS를 실행하므로 여전히 리소스 소모가 큼 3. Container Virtualization (컨테이너 가상화) ⭐ # 구조: 애플리케이션들이 호스트 OS 커널을 공유하면서도 격리된 환경을 유지합니다.\n장점:\n경량: 일반적으로 수십 MB (VM은 수십 GB) 빠른 시작 속도: 별도의 OS 부팅이 필요 없음 적은 리소스 사용: 시스템 리소스를 효율적으로 활용 높은 밀도: 같은 하드웨어에서 더 많은 컨테이너 실행 가능 단점:\n호스트 시스템과 동일한 OS 환경이 필요함 크로스 플랫폼 배포가 어려울 수 있음 (예: Linux 컨테이너는 Linux 호스트 필요) 📊 가상화 방식 비교 # 구분 호스트 가상화 하이퍼바이저 가상화 컨테이너 가상화 용량 수십 GB 수십 GB 수십 MB 시작 속도 느림 느림 매우 빠름 리소스 사용 높음 중간 낮음 격리 수준 높음 높음 중간 이식성 낮음 중간 높음 설정 난이도 쉬움 어려움 중간 💡 정리 # Docker 컨테이너 가상화의 핵심 가치:\n효율성: 기존 가상화 방식보다 훨씬 적은 리소스로 동일한 기능 제공 속도: 애플리케이션을 몇 초 안에 시작하고 중지 가능 일관성: 개발, 테스트, 프로덕션 환경에서 동일하게 실행 확장성: 필요에 따라 컨테이너를 쉽게 추가하거나 제거 Docker는 현대적인 애플리케이션 개발과 배포의 핵심 도구로, DevOps와 마이크로서비스 아키텍처의 기반이 되고 있습니다.\n","date":"2022-10-24","externalUrl":null,"permalink":"/posts/221024_about_docker/","section":"Posts","summary":"Docker는 애플리케이션을 컨테이너로 패키징하여 다양한 환경에서 안정적으로 실행할 수 있게 해주는 오픈소스 플랫폼입니다. 호스트 가상화, 하이퍼바이저 가상화, 컨테이너 가상화의 차이점과 각각의 장단점을 비교하고, Docker 컨테이너의 효율성과 활용 방법을 정리합니다.","title":"도커(Docker)란? \u0026 Docker Container 그리고 가상화 방식의 종류","type":"posts"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/series/deep-dive-into-network/","section":"Series","summary":"","title":"Deep Dive Into Network","type":"series"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/tags/dhcp/","section":"Tags","summary":"","title":"DHCP","type":"tags"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/tags/ip/","section":"Tags","summary":"","title":"IP","type":"tags"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/tags/ipv4/","section":"Tags","summary":"","title":"IPv4","type":"tags"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/tags/nat/","section":"Tags","summary":"","title":"NAT","type":"tags"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/categories/network/","section":"Categories","summary":"","title":"Network","type":"categories"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network","type":"tags"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/en/tags/private-network/","section":"Tags","summary":"","title":"Private Network","type":"tags"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/en/tags/public-network/","section":"Tags","summary":"","title":"Public Network","type":"tags"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/tags/vpn/","section":"Tags","summary":"","title":"VPN","type":"tags"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/tags/%EA%B3%B5%EC%9D%B8%EB%A7%9D/","section":"Tags","summary":"","title":"공인망","type":"tags"},{"content":" 사설망과 공중망, 어디선가 들어는 보았지만 개념은 잘 몰랐기에 정리를 해보고자 합니다. 사설 IP와 공인 IP의 관계 위 그림을 처음 보면 잉? 하겠지만 글을 모두 읽고 나면 아! 하면서 어느 정도 이해를 하실 수 있을 겁니다. 📅 2011년, IPv4 주소 고갈 선언 # 인터넷 주소 관리기구인 IANA(Internet Assigned Numbers Authority)에서는 더 이상의 IPv4의 할당은 없을 것이라고 선언을 하였습니다. IPv4는 대략 43억 개의 한정된 주소를 사용할 수 있는데 반해 인터넷의 수요가 빠르게 증가하여 각 대륙에 할당한 IPv4가 동이 나버린 거죠.\nIANA(Internet Assigned Numbers Authority)는 인터넷 할당 번호 관리기관의 약자로 IP 주소, 최상위 도메인 등을 관리하는 단체입니다. 현재 ICANN이 관리하고 있습니다. 그런데 어떻게 아직도 IPv4를 사용할까? # 그럼 현재 2022년, 무려 11년 전에 동이 나버린 IPv4임에도 불구하고 현재에도 우리는 IPv4를 잘 사용하고 있습니다. 이게 어떻게 된 걸까요?\n이 때문에 IPv6가 오래전 개발되어 조금씩 상용화되고 있습니다. 그럼에도 IPv4의 사용이 훨씬 더 많을 텐데 어떻게 11년이 지난 지금까지 잘 유지를 하고 있는 걸까요?\n이러한 이유는 사설망(Private Network) 덕분입니다. 🔌 사설망(Private Network)이란? # 사설망은 IPv4 중 특정 대역을 공인 인터넷이 아닌 가정, 기업 등의 한정된 공간에 사용한 네트워크를 의미합니다. 사설망에 소속된 IP인 사설 IP 대역은 오로지 사설망(내부망)에서만 사용이 가능하기 때문에 공인망(외부망, 인터넷)에선 사용을 할 수 없습니다.\n사설 IP 대역 공인 IP란? # 인터넷 상에서 서로 다른 PC끼리 통신하기 위해 필요한 IP로써 다음과 같은 용도로 사용됩니다:\n홈페이지 서버 구축 PC 인터넷 연결 인터넷을 통한 통신 공인 IP는 각 나라마다 관리하는 기관이 있는데, 우리나라는 한국 인터넷진흥원(KISA)에서 관리하고 있습니다. 공인 IP 주소 체계 💡 개념 정리 # 사설망은 가정 또는 기업 등의 한정된 공간에서만 사용이 가능합니다. 그럼 우리가 같은 사설망을 사용하지 않는 다른 PC들과 통신하기 위해선 어떻게 해야 할까요?\n공인 IP 가 필요합니다!\n즉, 사설망에서 공인 인터넷 통신을 하기 위해선 특별한 조치가 필요합니다. 사설 IP는 사설망에서만 사용하도록 규정이 되어 공인 인터넷에서는 사설 IP를 사용할 수 없는 거죠.\n🔄 NAT (Network Address Translation) # 이에 IP를 변환하기 위한 방법으로 고안된 것이 네트워크 주소 변환(NAT: Network Address Translation) 입니다.\nNAT란?\nIP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고받는 기술을 말합니다. 패킷에 변화가 생기기 때문에 IP나 TCP/UDP의 체크섬(checksum)도 다시 계산되어 재기록해야 합니다.\nNAT를 이용하는 이유는 대개 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함입니다.\n즉, 사설망에서 공인망으로, 공인망에서 사설망으로 통신하고자 할 때 공인망/사설망에서 사용하는 IP로 변환하는 것을 의미합니다. 위 설명에 따르면 IP 패킷의 TCP/UDP 포트 숫자를 변환한다고 하는 것은 실제로 NAT의 의미가 IP 주소뿐만 아니라 Port까지 변환시켜 사용하는 것을 포함하기 때문이라고 하네요!\nPAT 또는 NAPT (Port Address Translation)이라고 부릅니다.\n📡 공유기의 기능 # 요즘 대부분의 모든 집이 공유기를 (예: iptime, olleh 등) 설치하고 사용하고 있죠.\n이 공유기에는 다양한 기능이 존재합니다.\n1. DHCP 서버 기능 # 일단 하나의 공유기를 통해 연결된 다양한 기기에 IP를 할당해주는 DHCP(Dynamic Host Configuration Protocol) 서버의 기능이 존재합니다.\n동적 호스트 구성 프로토콜(DHCP)\nDHCP는 호스트 IP 구성 관리를 단순화하는 IP 표준입니다. DHCP 서버를 사용하여 IP 주소 및 관련된 기타 구성 세부 정보를 네트워크의 DHCP 사용 클라이언트에게 동적으로 할당하는 방법을 제공합니다.\n이를 통해 공유기에 연결한 집 내부의 스마트 기기 및 PC는 각각의 사설 IP를 할당받게 됩니다.\n왜 사설 IP를 할당받는 걸까요?\n맨 처음 설명으로 돌아가 보면 이해가 되겠죠\u0026hellip;?!\nIP 할당 개수는 한정되어 있기 때문에 집집마다, 아니 모든 기기마다 공인 IP를 할당할 수 없으니 사설 IP를 할당하여 사설망을 구축하는 거죠! 이렇게 사설망을 구축하여 내부적으로는 통신이 가능하지만 아직 외부 인터넷과는 통신을 할 수 없습니다.\n2. NAT 기능 # 그래서 공유기는 NAT 기능을 갖추고 있습니다.\n사설 IP를 공인 IP로 변환하는 기능 매핑 테이블을 자체 구축하여 NAT 테이블로 변환 전과 변환 후 값을 관리 물론 공유기가 자체적으로 공인 IP를 갖고 있는 것은 아닙니다! 공유기는 인터넷 업체(KT, SKT, LG 등)에서 제공받은 공인 IP 대역을 사용하는 것이죠! VPN(Virtual Private Network)이란? # 그럼 더 나아가 우리가 사용은 해봤을 수 있지만 정확히 어떤 역할을 하는지 잘 모르는 VPN에 대해 알아봅시다!\nVPN은 가상 사설망으로 이름 그대로 사설망이지만 가상인 사설망을 말합니다. 원래 알고 있던 VPN은 뭔가 IP를 변경하거나 IP를 속여 불법\u0026hellip; 🤔\n그런 건 줄 알고 있었지만 반은 맞고 반은 틀린 내용입니다!\nVPN의 진짜 의미 # VPN은 외부에 있는 컴퓨터에서 내부 네트워크(사설망)에 접속해 있는 것처럼 사용할 수 있는 것을 말합니다.\nVPN을 사용하였을 때 IP가 변경되는 이유도 위의 사설망/공중망을 잘 생각해 보면 이해할 수 있습니다.\nVPN을 통해 내부 네트워크(사설망) 안에 접속을 하였기 때문에 IP가 변경되는 것이죠! 💼 VPN 활용 사례 # 1. 재택근무/원격 근무 # 이를 통해 사설 네트워크가 구축되어 있는 회사에서 VPN 서버 설정을 해주고 외부 공인 IP 주소와 설정된 아이디/비밀번호를 통해 어디에서든 회사의 사설망에 접근을 할 수 있는 거죠.\n2. 원격 컴퓨터 접속 # 또한 개인 컴퓨터도 마찬가지로 VPN 설정을 통해 외부 공인 IP 주소만 알아놓고 있으면 어디에서든 VPN을 통해 서울에 있는 내 컴퓨터를 제주도에서도 접근할 수 있습니다.\n3. 지역 제한 우회 # 어떤 한 나라의 사이트에서 우리나라 IP로 접속하는 것을 차단했다고 하였을 때 우리는 그 사이트에 접속을 할 수 없습니다. 이 사이트에 접속을 하기 위해서 우리나라가 아닌 다른 나라의 IP 주소로 접근을 해주어야 하는데 이때 VPN을 통해 다른 나라의 내부 네트워크에 접속한 것처럼 하여 차단된 방화벽을 통과할 수 있습니다.\n4. 방화벽 우회 메커니즘 # 가상 시나리오\n회사에서 내부 규칙으로 회사 근무 중에 SNS에 접속하지 못하도록 차단하였다고 하였을 때 우리는 집에 구축해둔 VPN 또는 해외 VPN을 통해 접속을 해줍니다. 그럼 SNS에 접속을 할 수 있게 됩니다.\n왜 이러는 걸까요?\nVPN을 연결하는 순간 가상의 터널이 형성되고 터널 간의 통신을 위해 보내는 패킷들을 잘게 나누고 암호화와 캡슐화를 합니다. 이때 회사의 방화벽을 거치게 되지만 암호화/캡슐화된 패킷이기 때문에 내가 VPN을 통해 접속하려는 곳이 SNS인지 알아차리지 못하기 때문에 패킷을 그대로 통과시키게 됩니다.\nVPN 터널링 구조 📋 VPN 정리 # 👍 장점 # 데이터 보안 확보 🔒 온라인 프라이버시 보호 📍 IP 주소 변경 🛡️ 신변 보호 🚀 대역폭 제한 방지 👎 단점 # VPN은 위와 같이 여러 장점도 존재하지만 단점도 존재합니다.\n🐢 VPN에 접속한 장비는 VPN 서버와 암호화 통신을 해야 하기 때문에 네트워크 속도가 매우 느립니다 ⚠️ 신뢰성이 낮은 일부 VPN도 존재합니다 💰 보안성이 높은 VPN 사용 시에는 비용을 지불해야 합니다 🚫 일부 국가에서는 이용이 불가능합니다 ","date":"2022-10-05","externalUrl":null,"permalink":"/posts/221005_about_ip/","section":"Posts","summary":"사설 IP와 공인 IP의 차이, NAT(Network Address Translation)의 역할, 그리고 VPN이 어떻게 동작하는지 알아봅니다. IPv4 주소 고갈 문제를 해결한 사설망 개념부터 공유기의 NAT 기능, VPN의 실제 활용 사례까지 네트워크의 핵심 개념을 정리합니다.","title":"사설IP/공인IP? 사설망/공중망? VPN?","type":"posts"},{"content":"","date":"2022-10-05","externalUrl":null,"permalink":"/tags/%EC%82%AC%EC%84%A4%EB%A7%9D/","section":"Tags","summary":"","title":"사설망","type":"tags"},{"content":"","date":"2022-09-27","externalUrl":null,"permalink":"/series/deep-dive-into-springboot/","section":"Series","summary":"","title":"Deep Dive Into SpringBoot","type":"series"},{"content":"","date":"2022-09-27","externalUrl":null,"permalink":"/tags/dispatcher-servlet/","section":"Tags","summary":"","title":"Dispatcher Servlet","type":"tags"},{"content":"","date":"2022-09-27","externalUrl":null,"permalink":"/tags/servlet/","section":"Tags","summary":"","title":"Servlet","type":"tags"},{"content":"","date":"2022-09-27","externalUrl":null,"permalink":"/categories/spring/","section":"Categories","summary":"","title":"Spring","type":"categories"},{"content":"","date":"2022-09-27","externalUrl":null,"permalink":"/tags/spring/","section":"Tags","summary":"","title":"Spring","type":"tags"},{"content":" Dispatcher Servlet이란? # 디스패처 서블릿의 dispatch는 \u0026ldquo;보내다\u0026quot;라는 뜻을 가지고 있다. 이러한 단어의 뜻을 내포하는 디스패처 서블릿은 **HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)**라고 정의할 수 있다.\n동작 개요 # 좀 더 자세한 절차는 다음과 같다:\n클라이언트로부터 어떠한 요청이 들어오면 Tomcat과 같은 서블릿 컨테이너가 요청을 받게 된다 이 모든 요청을 프론트 컨트롤러인 디스패처 서블릿이 가장 먼저 받게 된다 디스패처 서블릿은 공통적인 작업을 먼저 처리한 후에 해당 요청을 처리해야 하는 컨트롤러를 찾아서 작업을 위임한다 Front Controller 패턴 # 여기서 Front Controller라는 용어는 주로 서블릿 컨테이너의 제일 앞에서 서버로 들어오는 클라이언트의 모든 요청을 받아서 처리해주는 컨트롤러로써, MVC 구조에서 함께 사용되는 디자인 패턴이다.\nDispatcher Servlet의 동작 방식 # 디스패처 서블릿은 가장 먼저 요청을 받는 Front-Controller이다.\n**서블릿 컨텍스트(Web Context)**에서 필터들을 지나 **스프링 컨텍스트(Spring Context)**에서 디스패처 서블릿이 가장 먼저 요청을 받게 된다 디스패처 서블릿은 적합한 컨트롤러와 메소드를 찾아 요청을 위임해야 하며 동작 방식은 아래와 같다.\n상세 동작 과정 # 1. HTTP Request가 Filter를 거쳐 Dispatcher Servlet이 받는다 # 2. 요청 정보를 확인하고 위임할 Controller를 찾는다 # HandlerMapping의 구현체 중 하나인 RequestMappingHandlerMapping은 @Controller로 작성된 모든 컨트롤러 빈을 파싱하여 HashMap으로 (요청정보, 처리대상)을 관리한다.\n요청에 매핑되는 컨트롤러와 해당 메소드 등을 갖는 HandlerMethod 객체를 찾는다. 그렇기 때문에 HandlerMapping은 요청이 오면 HTTP Method, URI 등을 사용해 Key 객체인 요청 정보를 만들고, Value인 요청을 처리할 HandlerMethod를 찾아 HandlerMethodExecutionChain으로 감싸서 반환한다.\n이렇게 감싸는 이유는 컨트롤러로 요청을 넘겨주기 전에 처리해야 하는 인터셉터 등을 포함하기 위함이다.\n3. Controller로 위임해줄 HandlerAdapter를 찾아 전달한다 # 디스패처 서블릿은 컨트롤러로 요청을 직접 위임하는 것이 아닌 HandlerAdapter를 통해 컨트롤러로 요청을 위임한다.\nHandlerAdapter 인터페이스를 거치는 이유는 컨트롤러를 구현하는 방식이 다양하기 때문이다. @Controller에 @RequestMapping 관련 어노테이션을 사용해 컨트롤러 클래스를 주로 작성하지만, Controller 인터페이스를 구현하여 컨트롤러 클래스를 작성할 수도 있다.\n그렇기 때문에 스프링은 HandlerAdapter라는 인터페이스를 통해 어댑터 패턴을 적용함으로써 컨트롤러의 구현 방식에 상관없이 요청을 Controller에 위임할 수 있는 것이다.\n4. HandlerAdapter가 Controller로 요청을 위임한다 # HandlerAdapter가 Controller로 요청을 넘기기 전에 공통적인 전/후 처리 과정이 필요하다.\n대표적으로:\n인터셉터 처리 요청 시 @RequestParam, @RequestBody 등을 처리하기 위한 ArgumentResolver 응답 시 ResponseEntity의 Body를 JSON으로 직렬화하는 등의 처리를 하는 ReturnValueHandler 이러한 처리들이 어댑터에서 컨트롤러로 전달되기 전에 처리된다. 그리고 컨트롤러의 메소드를 호출하도록 요청을 위임한다.\n5. Business Logic을 처리한다 # Controller는 서비스를 호출하고 비즈니스 로직을 진행한다.\n6. Controller가 반환값을 return한다 # ResponseEntity 또는 View 이름을 반환한다.\n7. HandlerAdapter가 return값을 처리한다 # HandlerAdapter는 컨트롤러로부터 받은 응답을 응답 처리기인 ReturnValueHandler가 후처리한 후에 디스패처 서블릿으로 돌려준다.\n컨트롤러가 ResponseEntity를 반환하면 → HttpEntityMethodProcessor가 MessageConverter를 사용해 응답 객체를 직렬화하고 응답 상태(HttpStatus)를 설정 View 이름을 반환하면 → ViewResolver를 통해 View를 반환 8. 서버의 응답을 클라이언트에게 전달한다 # DispatcherServlet을 통해 반환되는 응답은 다시 Filter를 거쳐 클라이언트에게 반환된다.\n","date":"2022-09-27","externalUrl":null,"permalink":"/posts/220927_dispatcher/","section":"Posts","summary":"Dispatcher Servlet이 클라이언트 요청을 받아 적절한 컨트롤러로 위임하는 Front Controller 패턴의 동작 원리와 전체 요청 처리 과정을 설명합니다","title":"Spring Dispatcher Servlet의 이해","type":"posts"},{"content":"","date":"2022-09-27","externalUrl":null,"permalink":"/tags/spring-mvc/","section":"Tags","summary":"","title":"Spring MVC","type":"tags"},{"content":"","date":"2022-09-27","externalUrl":null,"permalink":"/tags/web/","section":"Tags","summary":"","title":"Web","type":"tags"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/tags/class-loader/","section":"Tags","summary":"","title":"Class Loader","type":"tags"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/series/deep-dive-into-jvm/","section":"Series","summary":"","title":"Deep Dive Into JVM","type":"series"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/tags/garbage-collector/","section":"Tags","summary":"","title":"Garbage Collector","type":"tags"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/categories/java/","section":"Categories","summary":"","title":"Java","type":"categories"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/tags/jvm/","section":"Tags","summary":"","title":"JVM","type":"tags"},{"content":" JVM의 구성요소 # 1. 클래스 로더 (Class Loader) # JVM의 Class Loader는 javac에 의해 변환된 바이트코드 파일인 *.class 파일을 Runtime Data Areas에 로딩하여 프로그램을 구동한다.\nClass Loader의 로딩은 런타임에 일어나는데, 클래스에 처음 접근될 때 일어난다. 이를 통해 Lazy Loading Singleton이 구현되기도 한다.\nClass Loading 시간엔 Thread-safe 하다. 2. 실행 엔진 (Execution Engine) # Class Loader가 Runtime Data Areas에 불러온 바이트 코드를 실행한다. 바이트 코드를 기계어로 변경해 명령어 단위로 실행하는데, 1바이트의 OpCode와 피연산자로 구성이 된다.\n주요 구성요소 # 인터프리터 (Interpreter) 컴파일러 (Just-in-Time) 3. 가비지 콜렉터 (Garbage Collector) # Heap 영역에 참조되지 않는 오브젝트를 제거하는 역할을 한다.\n자바 이전에는 프로그래머가 모든 프로그램의 메모리를 관리했다. 자바에서는 JVM이 가비지 컬렉션이라는 프로세스를 통해 프로그램 메모리를 관리한다.\n가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할을 한다. 4. 런타임 데이터 영역 (Runtime Data Areas) # OS로부터 할당받은 JVM의 메모리 영역이다. 자바 어플리케이션을 실행하는데 필요한 데이터를 담는다.\nRuntime Data Areas는 아래와 같이 5개의 영역으로 나뉘어 진다.\n공유 영역\nMethod와 Heap 영역은 모든 Thread가 공유 Thread별 영역\nStack, PC Register, Native Method 영역은 각 Thread 마다 존재 (1) Method Area # JVM이 시작될 때 생성되고 JVM이 읽은 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드 및 메서드 코드, 정적 변수, 메서드의 바이트 코드 등을 보관한다.\nNon-Heap 영역으로 Permanent 영역에 저장이된다. JVM 옵션 중 PermSize(Permanent Generation의 크기)를 지정할 때 고려해야 할 요소이다. 1-1 Type Information # Interface 여부 패키지 명을 포함한 Type 이름 Type의 접근 제어자 연관된 Interface 리스트 1-2 Runtime Constant Pool # Type, Field, Method로의 모든 레퍼런스를 저장 JVM은 Runtime Contant Pool을 통해 메모리 상 주소를 찾아 참조한다. 1-3 Field Information # Field의 타입 Field의 접근 제어자 1-4 Method Information # Constructor를 포함한 모든 Method의 메타데이터를 저장 Method의 이름, 파라미터 수와 타입, 리턴 타입, 접근 제어자, 바이트코드, 지역 변수 section의 크기 등을 저장 1-5 Class Variable # static 키워드로 선언된 변수를 저장 기본형이 아닌 static 변수의 실제 인스턴스는 Heap 메모리에 저장 (2) Heap Area # new 연산자로 생성된 객체를 저장하는 공간이다.\n참조하는 변수나 필드가 존재하지 않으면 **GC(Garbage Collector)**의 대상이 된다. (3) Stack Area # Thread마다 별개의 Frame으로 저장하며, 저장되는 요소는 아래와 같다.\n3-1 Local Variable Area # 지역변수, 매개변수, 메소드를 호출한 주소 등 Method 수행 중 발생하는 임시데이터를 저장한다. 4바이트 단위로 저장되며, int, float 등 4바이트 기본형은 1개의 셀, double 등 8바이트의 기본형은 2개의 셀을 차지한다. bool은 일반적으로 1개의 셀을 차지한다. 3-2 Operand Stack # Method의 workspace 이다. 어떤 명령을 어떤 피연산자로 수행할 지 나타낸다. 3-3 Frame Data # Constant Pool Resolution, Method Return, Exception Dispatch 등을 포함한다. 참조된 Exception의 테이블도 가지고 있다. Exception이 발생하면 JVM은 이 테이블을 참고하여 어떻게 Exception을 처리할 지 정한다. (4) PC Register # Thread가 시작될 때 생성되며 생성될 때마다 생성되는 공간으로, 스레드마다 하나씩 존재한다.\nThread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 Thread가 현재 실행하고 있는 부분의 주소를 갖는다.\nOS는 PC(Program Counter) Register를 참고하여 CPU 스케줄링 시 해당 Thread가 다음에 어떤 명령어를 수행해야 하는지 알 수 있다. (5) Native Method Stack # 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다.\nJava가 아닌 다른 언어로 작성된 코드를 위한 공간이다. Java Native Interface를 통해 바이트 코드로 전환하여 저장하게 된다. 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역이다. JVM 실행 순서 # 메모리 할당\n프로그램이 실행되면 JVM은 OS로부터 이 프로그램을 실행하는데 필요한 메모리를 할당받음 JVM은 이 메모리를 여러 영역으로 나누어 사용한다 컴파일\nJava Compiler(javac)가 *.java 파일을 컴파일하여 *.class 인 자바 바이트코드로 변환시킨다 클래스 로딩\n컴파일된 *.class 파일들을 Class Loader를 통해 JVM 메모리 위에 로딩을 한다 바이트코드 해석\n로딩된 *.class 파일들은 Execution Engine을 통해 기계어로 해석된다 실행 및 관리\n해석된 바이트코드들은 메모리 영역에 배치되어 실질적인 수행을 하게 된다 실행과정 속에서 JVM은 필요에 따라 스레드 동기화나 가비지 컬렉터와 같은 메모리 관리 작업을 수행한다 ","date":"2022-09-23","externalUrl":null,"permalink":"/posts/220923_jvm_2/","section":"Posts","summary":"JVM의 4가지 핵심 구성요소와 Runtime Data Areas의 5가지 메모리 영역(Method, Heap, Stack, PC Register, Native Method Stack)을 깊이 있게 분석합니다.","title":"JVM(JavaVirtualMachine) 파헤치기 (2)","type":"posts"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/tags/memory-management/","section":"Tags","summary":"","title":"Memory Management","type":"tags"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/categories/programming/","section":"Categories","summary":"","title":"Programming","type":"categories"},{"content":"","date":"2022-09-23","externalUrl":null,"permalink":"/tags/runtime-data-areas/","section":"Tags","summary":"","title":"Runtime Data Areas","type":"tags"},{"content":"문득 Java라는 언어를 공부하면서 JVM에 대한 궁금증이 생겼다. 단순히 작성한 코드를 실행시켜주는 가상컴퓨터 이다 라고만 알고 있었기에 어떻게 동작을하고 하는 역할은 무엇인지 궁금해졌기에 파헤쳐보고자 한다.\nJVM이란? # Java Virtual Machine의 줄임말로 Java를 실행시키기 위한 가상컴퓨터 환경을 말한다.\n그럼 JVM이 하는 역할의 무엇일까? # Java는 OS에 종속적이지 않다.\n위와 같은 조건을 충족 시키며 작성한 코드가 실행되기 위해선 Java와 OS사이에 무언가가 필요하다.\n그게 바로 JVM이다.\n코드 실행 과정 # 작성한 소스코드인(원시코드) *.java 를 CPU가 인식하기 위해선 기계어(010101000101\u0026hellip;)로 변환이 이루어져야 한다.\n그럼 *.java 가 바로 기계어로 변환되어 실행이 되는건가\u0026hellip;? # 아니다. *.java 파일은 우선 JVM이 인식을 할 수 있도록 java bytecode(*.class)로 변환이 이루어진다.\n이 변환과정은 java 컴파일러에 의해 수행이 되어진다.\njava 컴파일러는 JDK를 설치하면 bin폴더에 존재하는 javac.exe 이다.\njavac 명령어를 통해 .class 파일을 생성할 수 있고 java 명령어를 통해 이 .class파일을 실행시킬 수 있다. 이제 OS에서 실행이 되는건가..? # 아니다\u0026hellip;. bytecode는 기계어가 아니므로 OS에서 바로 실행되지 않는다\u0026hellip;! 이때 JVM이 OS가 이 bytecode를 이해할 수 있도록 해석해주는 역할을 한다.\n이러한 JVM의 역할 덕분에 한 번 작성한 Java 코드가 OS에 상관 없이 실행이 될 수 있는 것이다.\n전체 프로세스 # *.java → *.class 인 bytecode 형태로 변환 → JIT(Just In Time) 컴파일러를 통해 기계어(binary code)로 변환\n# JIT (Just In Time) 컴파일러란? # JIT 컴파일 또는 **동적번역(dynamic translation)**이라고 불린다.\nJIT는 인터프리터 방식의 단점을 보완하기 위해 도입되었다.\n프로그램이 실제 실행하는 시점에 기계어로 번역을 한다.\n성능 특징 # 기계어는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행이 된다. JIT 컴파일러가 기계어로 컴파일 하는 과정은 바이트 코드를 인터프리팅하는 것보다 훨씬 느리지만 한 번 수행되면 그 이후로는 빠르다 그러나 한 번만 실행되는 코드라면 컴파일을 하지 않고 바로 인터프리팅하는 것이 유리하다 JIT 컴파일러를 사용하는 JVM은 해당 메서드가 얼마나 자주 수행되는지 체크를 하고 일정 정도를 넘을때에만 컴파일을 수행한다.\n인터프리터 방식이란? # 인터프리터는 실행 시마다 소스 코드를 한 줄씩 기계어로 번역하는 방식이기 떄문에 실행 속도는 정적 컴파일 언어보다 느리다.\n대표적인 인터프리터 언어 # 파이썬 (Python) 자바스크립트 (JavaScript) 데이터베이스 언어인 SQL 장단점 # 구분 설명 장점 프로그램 수정이 간단하다 단점 실행 속도가 컴파일 언어보다 느리다 컴파일러는 소스코드를 번역해서 실행 파일을 만들기 때문에 프로그램에 수정 사항이 발생하면 소스 코드를 다시 컴파일해야 한다.\n프로그램이 작고 간단하면 문제가 없지만 프로그램 덩치가 커지면 컴파일이 시간 단위가 되는 일이 많아진다.\n하지만 인터프리터는 소스코드를 수정해서 실행시키면 끝이기에 수정이 빈번히 발생하는 용도의 프로그래밍에서 많이 사용된다.\n","date":"2022-09-22","externalUrl":null,"permalink":"/posts/220922_jvm_1/","section":"Posts","summary":"Java Virtual Machine의 핵심 개념과 동작 원리를 파헤칩니다. 소스코드가 바이트코드로 변환되고 JIT 컴파일러를 통해 기계어로 실행되는 전체 과정을 이해해봅니다.","title":"JVM(JavaVirtualMachine) 파헤치기 (1)","type":"posts"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/tags/oop/","section":"Tags","summary":"","title":"OOP","type":"tags"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/en/tags/procedural-programming/","section":"Tags","summary":"","title":"Procedural Programming","type":"tags"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/series/programming-basics/","section":"Series","summary":"","title":"Programming Basics","type":"series"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/en/tags/programming-paradigm/","section":"Tags","summary":"","title":"Programming Paradigm","type":"tags"},{"content":" 객체지향(OOP)과 절차적 프로그래밍(PP) # 객체지향언어와 절차지향언어는 절대 반대되는 개념이 아니다. 그렇다면 객체지향언어와 절차지향언어는 무엇인가?\n우리는 보통 Java, Python, C# 등의 언어를 객체지향 언어라고 부르며 C언어는 절차지향언어라고 부른다. 하지만 어디까지나 이 언어들이 지향하는 것이지 C언어는 절차적 프로그래밍만 가능하고 Java나 Python 등은 객체적 프로그래밍만 가능하다는 것이 아니다.\n어떤 언어를 사용하든 상관없이 절차지향적 프로그래밍을 할 수 있다. 반대로 C언어를 사용하더라도 객체지향적으로 코딩을 할 수 있는 것이다.\n\u0026lsquo;절차지향\u0026rsquo;이라는 용어의 오해 # 사실 절차지향적 언어라 하는 것은 잘못된 것이다. 모든 프로그래밍 언어가 절차를 기반으로 두고 있는데 절차를 지향한다는 말은 앞뒤가 맞지 않는다.\n하나의 예를 비유하자면:\n역도라는 스포츠는 바벨을 이용한 운동을 기반으로 하는 것인데 바벨을 지향하는 스포츠라고 하는 것과 같은 맥락이다. 그럼 역도를 덤벨로 해야 하나\u0026hellip;? 다시 말해 절차지향이 아닌 절차적 프로그래밍이 맞는 것이다.\n객체지향 프로그래밍(OOP)와 절차적 프로그래밍(PP)는 어디까지나 프로그래밍을 하는데 있어 접근 방식의 차이가 있을 뿐 반대 개념은 아니다! 핵심 차이점 # 절차적 프로그래밍: 데이터를 중심으로 함수를 만들어 사용 객체지향 프로그래밍: 데이터와 기능(함수)들을 묶어 하나의 객체로 만들어 사용 절차적 언어와 객체지향언어를 구분하는 기준 # 여러가지 방식이 있겠지만 큰 틀에서는 아래와 같이 나뉜다.\n캡슐화, 다형성, 클래스 상속을 지원하는가? 데이터 접근 제한을 걸 수 있는가? 대게 위 기준을 만족하면 객체지향 성향이 강해진다고 보면 된다.\n절차적 프로그래밍 # 절차적 프로그래밍은 말 그대로 절차적으로 코드를 구성한다는 것이다.\n데이터에 대한 순서를 파악하고 필요한 기능을 함수로 만들어 절차적(순서대로) 진행시키는 방식\n객체지향 프로그래밍 # 객체지향 프로그래밍의 경우 기능들을 묶어 하나의 객체로 만든다.\n다시 말하면 각각의 객체를 생성하고 그 객체마다 할 수 있는 행위(기능)들과 데이터를 하나로 묶어주는 것이다.\n예시 # 자동차 호출 서비스를 구현한다고 가정해보자:\n자동차 객체: 자동차가 할 수 있는 행위(기능)를 하나로 묶음 기사 객체: 기사가 할 수 있는 행위를 묶음 승객 객체: 승객이 할 수 있는 행위를 묶음 각 객체의 메소드나 필드를 호출하면서 서로 간의 상호작용을 통해 알고리즘을 구성하는 방식이다.\n그럼 어떤 방식이 더 좋은가? # 정답은 없다. 필요에 맞게 사용을 하고 자신이 선호하는 스타일을 사용하면 된다. 과거의 프로그래밍 # 과거에는 현재처럼 큰 규모의 하드웨어와 소프트웨어가 필요치 않았다. 오래된 언어인 C, 포트란, 코볼 같은 절차적 언어의 대표라 할 수 있는 언어들이 사용되어졌다.\n현대의 프로그래밍 # 현대에 들어서면서 점점 소프트웨어 발전이 빨라졌고 이에 따라 코드들도 복잡해져갔다.\n그러다 보니 복잡한 알고리즘들이 꼬이기 시작했고 작성한 코드를 사람이 읽었을 때 이해하기 힘들거나 이해할 수 없는 스파게티 코드가 되어버린 것이다.\n이러한 문제의 대안으로 객체지향적 프로그래밍이 나온 것이다.\n왜 객체지향이 우세한가? # 다만 현재 기준 객체지향 프로그래밍이 우세하게 사용되어지고는 있다. 그 이유는:\n복잡한 프로그래밍일수록 절차적 프로그래밍을 사용한다면 코드들이 꼬이기 쉽다 확장성 측면에서도 유지 보수를 할 때 메리트가 떨어진다 절차적 프로그래밍 장단점 # 장점 # 객체나 클래스 생성 없이 바로 프로그래밍 필요한 기능을 함수로 만들어 복붙하지 않고 호출하여 사용 프로그램 흐름을 쉽게 추적 단점 # 각 코드들의 끈끈한 우정 때문에 수정이 힘들다 (유기성이 높아 추가, 수정이 힘듦) 디버그(오류검사)가 힘듦 객체지향 프로그래밍 장단점 # 장점 # 모듈화, 캡슐화로 유지보수가 편함 객체지향적으로 현실 세계와 유사성에 의해 코드를 이해하기 쉽다 객체는 그 자체가 하나의 프로그램으로 다른 프로그램에서도 재사용이 가능 단점 # 대부분의 객체 지향 프로그램은 속도가 상대적으로 느려지고 많은 양의 메모리를 사용하는 경향이 있음 현실세계와 유사성에 의해 코드를 이해하기 쉽게 만들기 위해 설계 과정에 있어 많은 시간이 들어간다 정답은 없다! 적재적소에 맞추어 사용하자 # 절차적 프로그래밍을 사용하는 경우 # 보통 프로젝트 규모가 크지 않고 재사용할 일이 크지 않는 경우에 많이 사용된다.\n장점:\n프로그램 자체가 가벼워짐 객체지향으로 만드는 것보다 개발시간과 인력도 줄어듦 객체지향 프로그래밍을 사용하는 경우 # 큰 규모의 프로젝트에서 코드들을 재사용해야 한다면 초기 개발비용을 제외하고 객체지향 프로그래밍이 적합하다.\n장점:\n유지보수 측면에서 안정적 마무리 # 오늘은 이렇게 객체지향 프로그래밍과 절차적 프로그래밍에 대해 알아보았다. 아직은 깊이있는 내용에 대해서는 알지 못하지만 여러 글들을 찾아보며 객체지향과 절차적 프로그래밍에 대한 큰 틀을 이해하고 넘어가고 다음번에 좀 더 깊이있게 들어가보자 한다! ","date":"2022-08-31","externalUrl":null,"permalink":"/posts/220831_about_oop/","section":"Posts","summary":"객체지향 프로그래밍과 절차적 프로그래밍의 개념, 차이점, 장단점을 알아보고 언제 어떤 방식을 사용해야 하는지 정리합니다.","title":"객체지향 프로그래밍과 절차적 프로그래밍에 대해 알아보자","type":"posts"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/tags/%EC%A0%88%EC%B0%A8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"절차적 프로그래밍","type":"tags"},{"content":"","date":"2022-08-31","externalUrl":null,"permalink":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","section":"Tags","summary":"","title":"프로그래밍 패러다임","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]